# agency l0: constitution (v1)

this doc locks the v1 product decisions for **agency**: a local-first runner manager that creates isolated git workspaces and launches **real** `claude` / `codex` TUIs inside tmux, then opens github PRs via `gh`.

if a change would force broad refactors across orchestration + git + UX, it belongs here.

---

## 1) purpose

agency exists to make "spin up an ai coding session on a clean branch" trivial, inspectable, and reversible.

core loop:
1. create workspace from a parent branch
2. run `claude` or `codex` in that workspace (tmux session)
3. push branch + create PR when ready (`agency push`)
4. user reviews anytime via PR or locally; runner may still be active
5. user explicitly confirms merge when satisfied
6. agency merges via `gh pr merge` and archives

PR creation rules:
- PR is created when branch has at least one commit ahead of parent AND branch is pushed
- `agency push <id>` is the idempotent PR-creator (creates if missing, updates if exists)
- `agency run` does NOT auto-create PR; user explicitly pushes when ready

---

## 2) explicit non-goals (v1)

- no planner mode, no council mode
- no headless/exec automation, no background "agent brains"
- no attempt to infer "needs input" from model text
- no sandboxing/containers/VM isolation
- no cross-host orchestration (ssh, remote daemons, distributed runners)
- no multi-repo monorepo intelligence; repo boundaries are literal filesystem roots

---

## 3) implementation substrate

v1 is implemented in **Go**.

rationale:
- single static binary (no runtime dependencies)
- good process control (spawning tmux, managing pids)
- cross-platform (darwin/linux; windows deferred)
- fast startup for CLI tool

this is a hard constraint; changing languages post-v1 requires full rewrite.

---

## 4) primitives and definitions

**repo**
- a local git checkout with a configured `origin` remote for github.

**repo identity**
- primary: `origin_url` (normalized: strip `.git` suffix, lowercase host)
- secondary: `repo_root_commit` (sha of first commit, immutable)
- tertiary: `abs_path` (for convenience; may change if repo moves)
- agency detects repo moves and migrates pointers

**workspace (aka run)**
- the durable unit agency manages:
  - a git worktree + branch
  - a tmux session (may or may not have live runner)
  - persisted metadata (global storage)
  - optional github PR url
- a workspace can survive multiple runner invocations.

**run_id**
- machine-unique identifier: `<timestamp>-<random>` (e.g., `20250109-a3f2`)

**title**
- human-provided string at run creation (or derived from prompt/task)
- used for PR title and display

**slug**
- sanitized title for branch names: lowercase, hyphens, truncated
- branch format: `agency/<slug>-<shortid>` where shortid is derived from run_id

**invocation**
- one execution of `claude` or `codex` inside the workspace tmux session.
- invocations may exit at any time. the workspace persists.
- agency prefers to keep runner alive (preserves history) but never depends on it.
- runner can always be relaunched in existing workspace.

**runner**
- the chosen interactive tool: `claude` or `codex`.

---

## 5) hard constraints (irreversible choices)

- implementation in **Go**
- github-only integration via **`gh` CLI**
- tmux is the **only** attach/detach substrate in v1
- work isolation is via **git worktrees**
- `agency.json` is **mandatory** at repo root
- scripts are **required** (setup / verify / archive)
- merge gate is the **human**: explicit confirmation is required; agency never auto-merges

---

## 6) trust boundaries and safety posture

- agency is a local developer tool. it executes runner TUIs and repo-defined scripts.
- agency does **not** try to protect users from themselves:
  - the runner has whatever access the user's environment grants.
  - repo scripts can do anything.
- therefore: agency must be transparent:
  - all state is stored as plain files on disk
  - commands executed are logged
  - nothing "mystical" happens off-screen

security defaults:
- agency itself does not invent secret handling.
- any `.env` linking/copying is solely the setup script's responsibility.
- agency does not upload code anywhere except `git push` to the configured github remote.

### interactivity rules

**scripts**: never prompt, ever. they run in detached tmux and cannot receive input.

**agency commands**: may prompt only when invoked directly by user in foreground. never prompt during:
- `agency run` background flows
- script execution
- any automated/batch operation

### gh authentication requirement

`gh` can be interactive (auth prompts), which will hang in a detached tmux session.

v1 requirement: user must be pre-authenticated with `gh`.

before any PR/push operations, agency checks `gh auth status`. if it fails:
- abort with `E_GH_NOT_AUTHENTICATED`
- instruct user to run `gh auth login`

---

## 7) required repo contract: `agency.json`

`agency.json` MUST exist at repo root and MUST define:

- `scripts.setup`: prepare fresh workspace (deps, env, etc.)
- `scripts.verify`: validate readiness (tests/lint/etc.)
- `scripts.archive`: cleanup / teardown optional resources
- `defaults.parent_branch`: default parent branch (e.g. `"main"`)
- `runners`: how to launch `claude` and/or `codex`

optional:
- `report_mode`: `pr_body` (default) or `repo_file`

example:

```json
{
  "version": 1,
  "defaults": {
    "parent_branch": "main",
    "runner": "claude"
  },
  "scripts": {
    "setup": "./scripts/agency_setup.sh",
    "verify": "./scripts/agency_verify.sh",
    "archive": "./scripts/agency_archive.sh"
  },
  "runners": {
    "claude": { "cmd": "claude" },
    "codex":  { "cmd": "codex" }
  }
}
```

### script operational requirements

all scripts must be:
- **non-interactive**: no prompts, ever
- **idempotent**: safe to re-run
- **bounded**: agency enforces timeouts (implementation-defined)

### script execution context

scripts receive environment variables:
- `AGENCY_RUN_ID`: run identifier
- `AGENCY_WORKTREE`: absolute path to worktree
- `AGENCY_PARENT_BRANCH`: branch this run is based on
- `AGENCY_BRANCH`: branch name for this run
- `AGENCY_PR_URL`: PR url (empty if no PR yet)
- `AGENCY_REPO_ROOT`: absolute path to main repo

execution:
- cwd = worktree root
- stdout/stderr captured to run logs
- non-zero exit = failure (affects workspace status)
- env linking/copying is solely setup script's responsibility

### script output contract

scripts may write structured output to known paths in worktree:
- `.agency/setup.json` (optional; setup script metadata)
- `.agency/verify.json` (required from verify; pass/fail + details)
- `.agency/archive.json` (optional; archive script metadata)

agency reads these for evidence. if verify.json is missing after verify runs, treat as failure.

---

## 8) storage model

### global store (`~/.agency/`) — canonical

all heavy state lives here:

```
~/.agency/
  repos/<repo_id>/
    repo.json             # origin_url, root_commit, last_seen_path, config_checksum
    runs/<run_id>/
      meta.json           # canonical run metadata
      transcript.txt      # tmux capture (rolling)
      result.json         # derived status + evidence
    worktrees/<run_id>/   # actual git worktree
```

`repo_id` = truncated sha256 of normalized `origin_url`.

### repo-local (`.agency/` inside repo root) — minimal

lightweight index only:
- `.agency/repo_id` — single line: the repo_id linking to global store

this file is gitignored. it exists so agency can find the global store from the repo.

if repo moves:
- agency detects path mismatch on next invocation
- updates `last_seen_path` in global `repo.json`
- no data loss

### worktree-local (`.agency/` inside worktree) — runner-writable

runner-editable files live here (gitignored):
- `.agency/report.md` — report template, editable by runner
- `.agency/verify.json` — written by verify script
- `.agency/setup.json` — optional, written by setup script

agency syncs `.agency/report.md` to PR body on `agency push`.

### locking and concurrency

- per-run lock: file lock on `~/.agency/repos/<repo_id>/runs/<run_id>/.lock` during meta.json updates
- per-repo lock: file lock on `~/.agency/repos/<repo_id>/.lock` during worktree create/remove

two agency processes must not corrupt state.

---

## 9) tmux conventions

- session name: `agency:<run_id>`
- one primary window/pane per workspace for the runner tui
- attach/detach semantics are tmux-native:
  - detached run = tmux session exists, no client attached
  - `agency attach <id>` attaches to existing session

agency must never implement its own pty multiplexer in v1.

---

## 10) git + github conventions

### branch naming

format: `agency/<slug>-<shortid>`
- slug: sanitized title (lowercase, hyphens, max 40 chars)
- shortid: first 4 chars of run_id random component

### PR workflow

before push, agency runs `git fetch origin <parent_branch>` to ensure parent is current.

`agency push <id>`:
1. fetch origin parent branch
2. if local parent is behind origin parent: warn but proceed (user can rebase manually)
3. push branch to origin
4. if no PR exists and branch has commits ahead of parent: create PR via `gh pr create`
5. sync `.agency/report.md` to PR body
6. store PR url + number in run metadata

PR title: `[agency] <title>`

### merge workflow

`agency merge <id>`:
1. ensure PR exists (create via push if missing)
2. ensure local head is pushed
3. check `gh pr view --json mergeable` — if not mergeable, fail with `E_PR_NOT_MERGEABLE`
4. run `scripts.verify`, record result
5. if verify failed: prompt "verify failed, continue? [y/N]" (skip with `--force`)
6. require explicit human confirmation
7. merge via `gh pr merge` (strategy from flags/config)
8. archive workspace (run `scripts.archive`, remove worktree + tmux session)

### canonical merge path (v1)

v1 uses `gh pr merge` exclusively:
- strategy via `--merge`, `--squash`, `--rebase` flags or config default
- local merge (without PR) deferred to post-v1

conflicts / not mergeable:
- if `gh` reports PR not mergeable: fail immediately, require human intervention
- no auto-rebase or conflict resolution in v1

---

## 11) statuses and how they're computed

agency statuses are derived from evidence, not model claims.

### status definitions

**terminal statuses** (highest precedence):
- `merged`: PR merged via `gh pr merge`
- `abandoned`: user-marked + archived
- `failed`: setup failed OR catastrophic error

**workflow statuses**:
- `ready_for_review`: PR open AND pushed AND report synced
- `needs_attention`: verify failed OR user-marked OR PR checks failing

**execution statuses** (lowest precedence):
- `running`: tmux session exists AND runner process alive
- `idle`: workspace exists, runner not alive (or no tmux session)

### status derivation order

precedence matters. terminal states always win:

1. PR merged? → `merged` (even if tmux session somehow exists)
2. user-marked abandoned + archived? → `abandoned`
3. setup failed / catastrophic? → `failed`
4. tmux session exists + runner alive? → `running`
5. PR open + pushed + report synced? → `ready_for_review`
6. verify failed / user-marked needs_attention? → `needs_attention`
7. otherwise → `idle`

### runner-alive detection

best-effort pid check:
1. check tmux session `agency:<run_id>` exists
2. if exists, get pane pid via `tmux list-panes -t agency:<run_id> -F '#{pane_pid}'`
3. check if runner process (claude/codex) is in process tree under that pid
4. alive → `running`; dead → fall through to workflow status

### ready_for_review predicate

requires:
- PR exists and is open
- local branch head matches origin (or successful `agency push` recorded)
- `.agency/report.md` synced to PR body (agency tracks sync state)

does NOT require runner to be idle; review can happen while runner is active.

---

## 12) report artifacts

### canonical path: worktree-local

report lives at `<worktree>/.agency/report.md` — editable by runner.

template (created by agency at workspace init):
```markdown
# <title>

## Summary
<!-- what changed and why -->

## Deviations
<!-- departures from original task -->

## How to Test
<!-- exact commands -->

## Follow-ups
<!-- questions for reviewer -->
```

### sync behavior

- `agency push` reads `.agency/report.md` and updates PR body
- agency tracks sync state (hash of last synced content)
- `ready_for_review` requires report synced

### optional mode: repo file

opt-in via `report_mode: repo_file` in agency.json:
- commits report to `docs/agency/reports/<run_id>.md`
- PR body links to committed file
- runner edits the committed file directly

default is `pr_body` mode (worktree-local, synced to PR).

### machine-facing artifacts

stored in global run directory (not worktree):
- `~/.agency/repos/<repo_id>/runs/<run_id>/result.json`
- written by agency from evidence (tmux/git/gh/verify)

---

## 13) user flows (golden path)

```
# 0. first time: initialize repo
agency init
# creates agency.json template, adds .agency/ to .gitignore

# 1. start a run
agency run --title "implement feature X" --runner claude

# 2. attach/detach as needed
agency attach <id>
# (ctrl-b d to detach)

# 3. push when ready for review
agency push <id>
# creates PR if missing, syncs report to PR body

# 4. review via github or locally
# runner may still be active

# 5. merge when satisfied
agency merge <id>
# prompts for confirmation, runs verify, merges via gh, archives
```

---

## 14) product principles (enforced by design)

- **inspectability over cleverness**: everything important is visible on disk or in git.
- **git-native undo**: checkpoints are commits/stashes, not "undo the ai".
- **human merge gate**: the user is the final authority; agency assists, it does not decide.
- **repo-defined reality**: setup/verify/archive scripts are mandatory; agency does not guess.

---

## 15) v1 command surface

agency must remain scriptable. both interactive tui and subcommands are supported.

minimal subcommands:
- `agency init` — create agency.json template, add .agency/ to .gitignore
- `agency run [--title <t>] [--runner <r>]` — create workspace, run setup, start tmux with runner
- `agency ls` — list workspaces + statuses
- `agency attach <id>` — attach to tmux session
- `agency stop <id>` — signal runner / stop session (does not delete)
- `agency push <id>` — push branch, create/update PR, sync report (idempotent)
- `agency merge <id>` — confirm, verify, merge via gh, archive
- `agency clean <id>` — archive + delete without merging
- `agency mark <id> <status>` — manual status override

tui (optional in v1):
- `agency` opens interactive interface calling same underlying commands.

---

## 16) invariants (what must never happen)

- agency must never silently modify the parent branch working tree
- agency must never merge without explicit user confirmation
- agency must never create a workspace without `agency.json` present
- agency must never invent secret handling; only repo scripts manage env
- agency must never require a custom daemon in v1 (tmux is sufficient)
- agency must never attempt PR/push without verifying `gh auth status` first
- agency must never create nested worktrees
- agency must never delete dirty worktree without `--force`
- agency must never create PR for empty diff (no commits ahead of parent)
- agency must never corrupt state under concurrent access (file locks required)
- agency must never prompt during script execution or background flows
