# agency slice 00 / pr-02: agency.json schema + strict validation

## goal
implement loading and strict validation of `agency.json` (schema v1) plus runner command resolution rules. expose a single “first validation error” string suitable for `agency doctor`. no init/doctor command wiring yet beyond calling these functions in stubs.

## scope
in scope:
- define go structs for `agency.json` v1
- load `agency.json` from repo root path (provided by caller)
- strict validation with crisp, stable error messages:
  - version must be 1
  - required fields present and non-empty:
    - `defaults.parent_branch`
    - `defaults.runner`
    - `scripts.setup`, `scripts.verify`, `scripts.archive`
  - types must match (objects where objects expected, strings where strings expected)
  - `runners` values must be non-empty strings when present
  - reject empty string for any required string field
  - reject unknown top-level keys? (v1 decision: **do NOT reject** unknown keys; ignore them. but reject unknown *types*.)
- runner resolution logic:
  - if `runners[defaults.runner]` exists: use that command string
  - else if `defaults.runner` is exactly `claude` or `codex`: treat as PATH-fallback command name
  - else: validation error `E_RUNNER_NOT_CONFIGURED`
- resolve scripts paths as strings only (no filesystem checks here; doctor does that later)
- produce:
  - validated config object
  - a deterministic “first error” string for doctor on failure

out of scope (hard):
- filesystem checks (script exists/executable)
- PATH lookup / `exec.LookPath` (doctor does that)
- reading any other files besides agency.json
- writing any files
- implementing real `agency init` or `agency doctor`
- any worktrees/tmux/scripts execution

## public surface area
no CLI surface changes required.

new internal packages/files (expected):
- `internal/config/agencyjson.go` (structs + load)
- `internal/config/validate.go` (validation + resolution helpers)

## schema: agency.json v1
the accepted json shape:

```json
{
  "version": 1,
  "defaults": {
    "parent_branch": "main",
    "runner": "claude"
  },
  "scripts": {
    "setup": "scripts/agency_setup.sh",
    "verify": "scripts/agency_verify.sh",
    "archive": "scripts/agency_archive.sh"
  },
  "runners": {
    "claude": "claude",
    "codex": "codex"
  }
}

notes:
	•	runners is optional.
	•	unknown keys at top-level and inside objects are ignored (forward compatible).
	•	but if a known key exists with wrong type, fail.
	•	runner command values must be single executable names (no args).

APIs to implement (internal)

define:

type AgencyConfig struct {
  Version  int             `json:"version"`
  Defaults Defaults        `json:"defaults"`
  Scripts  Scripts         `json:"scripts"`
  Runners  map[string]string `json:"runners,omitempty"`

  // Derived (not from JSON):
  ResolvedRunnerCmd string `json:"-"`
}

type Defaults struct {
  ParentBranch string `json:"parent_branch"`
  Runner       string `json:"runner"`
}

type Scripts struct {
  Setup   string `json:"setup"`
  Verify  string `json:"verify"`
  Archive string `json:"archive"`
}

func LoadAgencyConfig(fs FS, repoRoot string) (AgencyConfig, error)
func ValidateAgencyConfig(cfg AgencyConfig) (AgencyConfig, error)

// for doctor-style single error output:
func FirstValidationError(err error) string

behavior:
	•	LoadAgencyConfig reads <repoRoot>/agency.json.
	•	if missing: return E_NO_AGENCY_JSON
	•	if invalid json: return E_INVALID_AGENCY_JSON with message “invalid json: ”
	•	must not require repo discovery here; caller provides repoRoot.
	•	ValidateAgencyConfig:
	•	returns cfg with ResolvedRunnerCmd set
	•	on failure returns typed AgencyError with code:
	•	E_INVALID_AGENCY_JSON for schema/type/required-field errors
	•	E_RUNNER_NOT_CONFIGURED for runner resolution errors

FirstValidationError:
	•	returns a stable, human actionable single line, e.g.:
	•	missing required field defaults.parent_branch
	•	defaults.runner must be a non-empty string
	•	scripts.verify must be a non-empty string
	•	version must be 1
	•	runner "foo" not configured; set runners.foo or choose claude/codex
	•	runners.claude must be a single executable name (no args)

validation rules (exact)
	•	version:
	•	required
	•	must equal 1
	•	defaults:
	•	required object
	•	parent_branch required non-empty string
	•	runner required non-empty string
	•	scripts:
	•	required object
	•	setup, verify, archive required non-empty strings
	•	runners:
	•	if present must be an object
	•	all values must be strings (json decoder enforces if using map[string]string; but you must detect wrong types by decoding into map[string]any first or by a strict unmarshal strategy—see below)
	•	reject empty string values for any entry
	•	runner commands must be a single executable name (no args); otherwise `E_INVALID_AGENCY_JSON`

runner resolution:
	•	let name = defaults.runner
	•	if cfg.Runners != nil and cfg.Runners[name] exists:
	•	cmd must be non-empty string and a single executable name; else error E_INVALID_AGENCY_JSON (runners.<name> invalid)
	•	ResolvedRunnerCmd = that string
	•	else if name == "claude" || name == "codex":
	•	ResolvedRunnerCmd = name (PATH fallback; doctor verifies it exists)
	•	else:
	•	return E_RUNNER_NOT_CONFIGURED

implementation note: strict type validation

go’s encoding/json will silently drop unknown fields and can’t easily report wrong nested types if you decode directly into structs with map[string]string.
requirement: if a known field exists but has the wrong type, fail.

suggested approach:
	•	unmarshal raw bytes into map[string]json.RawMessage at top level
	•	for each known field, unmarshal raw into the expected type and catch errors
	•	also unmarshal into the struct for convenience after type checks (or just build the struct as you go)

minimum required type failures to catch:
	•	version is string/float/object instead of number
	•	defaults is string instead of object
	•	scripts is array instead of object
	•	scripts.setup is object instead of string
	•	runners is array instead of object
	•	runners.claude is number instead of string

error codes used in this PR
	•	E_NO_AGENCY_JSON
	•	E_INVALID_AGENCY_JSON
	•	E_RUNNER_NOT_CONFIGURED

(no new codes beyond these.)

tests

fixtures

add internal/config/testdata/:
	•	valid_min.json
	•	missing_defaults.json
	•	missing_parent_branch.json
	•	wrong_version.json
	•	wrong_types.json (defaults as string; scripts.verify as object; runners value as number)
	•	empty_strings.json
	•	runner_custom_ok.json (defaults.runner=custom, runners.custom=“path/to/cmd”)
	•	runner_custom_missing.json (defaults.runner=custom, runners missing)

unit tests (required)
	1.	load:

	•	missing file -> E_NO_AGENCY_JSON
	•	invalid json -> E_INVALID_AGENCY_JSON with “invalid json” prefix

	2.	validate required fields:

	•	each missing/empty field triggers E_INVALID_AGENCY_JSON
	•	FirstValidationError returns the expected line (golden assertions)

	3.	type strictness:

	•	wrong nested types produce E_INVALID_AGENCY_JSON (do not silently accept)
	•	runners entries with args (e.g., "asdf exec claude") -> E_INVALID_AGENCY_JSON

	4.	runner resolution:

	•	runners map overrides defaults.runner -> resolved cmd set
	•	defaults.runner=claude/codex with no runners -> resolved cmd = name
	•	defaults.runner=custom with no runners -> E_RUNNER_NOT_CONFIGURED

constraints
	•	tests must not touch real filesystem outside temp dirs; use FS stub or os temp dir.
	•	no calls to external commands.

acceptance
	•	go test ./... passes
	•	package internal/config exposes only what later PRs need; avoid exporting extra helpers.
	•	CLI still builds; init/doctor may still return not implemented.

guardrails
	•	do not add doctor/init implementations
	•	do not add script existence/executable checks
	•	do not add persistence code
	•	do not add third-party deps
