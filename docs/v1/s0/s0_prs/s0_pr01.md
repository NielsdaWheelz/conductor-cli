# agency slice 00 / pr-01: directory resolution + repo discovery + origin parsing (pure logic)

## goal
implement deterministic directory resolution, repo root discovery, and repo identity parsing (repo_key + repo_id) with table-driven tests. this PR must be “pure logic + tests”: no commands beyond `git rev-parse`/`git config`, no persistence, no init/doctor behavior.

## scope
in scope:
- directory resolution per constitution (data/config/cache)
- repo root discovery via `git rev-parse --show-toplevel` through `CommandRunner`
- origin url retrieval via `git config --get remote.origin.url` through `CommandRunner`
- pure parsing of origin url into:
  - `repo_key` (`github:<owner>/<repo>` when github.com ssh/https)
  - otherwise `repo_key` = `path:<sha256(abs_repo_root)>`
- derive `repo_id` from `repo_key` as `sha256(repo_key)` truncated to a constant length
- helper types to carry “origin present/host/url” and “github flow available” boolean
- table-driven unit tests for all of the above

out of scope (hard):
- `agency init` or `agency doctor` real implementations
- any filesystem writes (no repo_index/repo.json)
- any external commands besides the two git commands above
- any gh/tmux checks
- any worktrees/tmux sessions/scripts execution
- any JSON schemas for persistence

## public surface area
no new CLI flags or commands required. `agency init`/`doctor` may remain not implemented.

new internal packages/files (expected):
- `internal/paths/xdg.go`
- `internal/git/repo.go`
- `internal/identity/origin_parse.go`
- `internal/identity/repo_id.go`

## commands executed (allowed)
this PR may call only these, via `CommandRunner`:
- `git rev-parse --show-toplevel`
- `git config --get remote.origin.url`

no `git status`, no `gh`, no `tmux`, no network calls.

## exact behaviors

### directory resolution
implement three functions:

```go
type Dirs struct {
  DataDir  string
  ConfigDir string
  CacheDir string
}

type Env interface { Get(string) string }
func ResolveDirs(env Env, homeDir string) Dirs

rules (exact, match constitution):
	•	data dir:
	1.	if env[“AGENCY_DATA_DIR”] != “” use it
	2.	else if darwin: <homeDir>/Library/Application Support/agency
	3.	else if env[“XDG_DATA_HOME”] != “” use path join: $XDG_DATA_HOME/agency
	4.	else use: <homeDir>/.local/share/agency
	•	config dir:
	1.	if env[“AGENCY_CONFIG_DIR”] != “” use it
	2.	else if darwin: <homeDir>/Library/Preferences/agency
	3.	else if env[“XDG_CONFIG_HOME”] != “” use $XDG_CONFIG_HOME/agency
	4.	else use <homeDir>/.config/agency
	•	cache dir:
	1.	if env[“AGENCY_CACHE_DIR”] != “” use it
	2.	else if darwin: <homeDir>/Library/Caches/agency
	3.	else if env[“XDG_CACHE_HOME”] != “” use $XDG_CACHE_HOME/agency
	4.	else use <homeDir>/.cache/agency

notes:
	•	do not touch filesystem in resolver (no mkdir).
	•	path joining must be OS-correct (filepath.Join).
	•	do not expand ~ inside env vars; treat as literal (documented).

repo root discovery

implement:

type RepoRoot struct {
  Path string // absolute, clean, no trailing newline
}

func GetRepoRoot(ctx context.Context, cr CommandRunner, cwd string) (RepoRoot, error)

behavior:
	•	run git rev-parse --show-toplevel with opts.Dir = cwd
	•	on exit_code != 0 -> return E_NO_REPO
	•	stdout is repo root path (may be relative); must:
	•	reject multi-line output (if stdout contains '\n' after trim)
	•	if empty -> E_NO_REPO
	•	if absolute: abs = filepath.Abs(filepath.Clean(out))
	•	if relative: abs = filepath.Abs(filepath.Join(cwd, filepath.Clean(out)))
	•	no symlink resolution required in v1 (do not call EvalSymlinks)

origin url retrieval

implement:

type OriginInfo struct {
  Present bool
  URL     string // empty if not present
  Host    string // empty if not present or unparsable
}

func GetOriginInfo(ctx context.Context, cr CommandRunner, repoRoot string) (OriginInfo, error)

behavior:
	•	run git config --get remote.origin.url with opts.Dir = repoRoot
	•	if exit_code != 0 or stdout trims to empty: return Present=false, URL=””, Host=””
	•	else:
	•	Present=true
	•	URL=trimmed stdout
	•	Host=ParseOriginHost(URL)

origin parsing → repo_key (pure function; no commands)

implement:

type RepoIdentity struct {
  RepoKey string // github:owner/repo OR path:<sha256(abs_repo_root)>
  RepoID  string // sha256(RepoKey) truncated
  GitHubFlowAvailable bool // true iff origin host == "github.com" AND owner/repo parse succeeded
  Origin OriginInfo
}

func DeriveRepoIdentity(absRepoRoot string, originURL string) RepoIdentity

func ParseOriginHost(raw string) string
func ParseGitHubOwnerRepo(raw string) (owner, repo string, ok bool)

repo_key rules (exact):
	•	if originURL matches one of:
	•	ssh scp-like ONLY: git@github.com:<owner>/<repo>(.git)?
	•	https ONLY: https://github.com/<owner>/<repo>(.git)?
then:
	•	owner and repo must be extracted
	•	strip trailing .git if present
	•	repo_key = github:<owner>/<repo> (preserve case; validate [A-Za-z0-9_.-]+)
	•	GitHubFlowAvailable = true
	•	else:
	•	repo_key = path:<sha256(absRepoRoot)>
	•	GitHubFlowAvailable = false
	•	OriginInfo is derived from originURL inside this function (Present true iff originURL non-empty)

ParseOriginHost rules:
	•	accept scp-like only when raw matches: git@host:owner/repo(.git)?
	•	accept https only; any other URL scheme returns ""
	•	ssh://... is unsupported and must return ""

ParseGitHubOwnerRepo rules:
	•	extract owner/repo for supported github.com ssh/https formats only
	•	strip trailing .git
	•	validate owner/repo match [A-Za-z0-9_.-]+; otherwise return ok=false

hashing:
	•	sha256 hex lowercase.
	•	define constants:
	•	const RepoIDLen = 16 // hex chars
	•	const PathHashLen = 64 // full sha256 hex
	•	repo_id = sha256(repo_key)[:RepoIDLen]
	•	path_hash = sha256(absRepoRoot) full hex inside repo_key

helper: sha256Hex

provide a pure helper:

func Sha256Hex(s string) string

error codes

this PR introduces/uses:
	•	E_NO_REPO (returned by GetRepoRoot)
no other new codes.

notes:
	•	GetOriginInfo never returns an error
	•	DeriveRepoIdentity never returns an error

tests

unit tests (required)
	1.	ResolveDirs:

	•	table-driven matrix covering:
	•	AGENCY_DATA_DIR override
	•	XDG_DATA_HOME fallback (non-darwin)
	•	darwin defaults for data/config/cache
	•	default fallback
	•	config/cache env overrides vs defaults
	•	verify exact output strings given homeDir /home/x (use filepath.FromSlash for portability).
	•	use a tiny map-backed Env stub for tests

	2.	origin host parsing:

	•	scp-like ssh:
	•	git@github.com:foo/bar.git -> host github.com
	•	git@github.com:foo/bar -> host github.com
	•	git@enterprise.example.com:foo/bar.git -> host enterprise.example.com
	•	https:
	•	https://github.com/foo/bar.git -> host github.com
	•	https://github.com/foo/bar -> host github.com
	•	weird formats:
	•	ssh://git@github.com/foo/bar.git -> Host=”” (unsupported in v1)
	•	empty string -> Present false behavior (handled in GetOriginInfo tests)

	3.	DeriveRepoIdentity:

	•	github ssh/https produce github:owner/repo and GitHubFlowAvailable true
	•	non-github host produces path:<hash> and GitHubFlowAvailable false
	•	origin missing produces path key + false
	•	ensures .git stripped
	•	ensures repo_id truncation length is constant and deterministic
	•	rejects invalid owner/repo chars

	4.	GetRepoRoot and GetOriginInfo with stubbed CommandRunner:

	•	success paths return trimmed values and set Present correctly
	•	failure exit codes map to E_NO_REPO for GetRepoRoot
	•	multi-line stdout from git rev-parse -> E_NO_REPO
	•	origin missing exit code or empty stdout -> Present=false
	•	stubbed CommandRunner asserts name + args + Dir match exactly

test constraints
	•	no tests may require git installed or a real repo
	•	use a stub CommandRunner that returns scripted CmdResult by (name,args,dir) matching.

acceptance
	•	go test ./... passes
	•	internal packages compile with no unused exported APIs
	•	no persistence or side-effects beyond pure functions and CommandRunner calls

guardrails
	•	do not implement doctor/init
	•	do not introduce persistence schemas or file writes
	•	do not add new external commands beyond allowed list
	•	do not add third-party deps

notes for implementer
	•	keep origin parsing intentionally narrow. do not “support more formats” in v1.
	•	keep hashing helpers centralized (internal/identity).
	•	ensure all string trimming uses TrimSpace to drop newlines from git output.
