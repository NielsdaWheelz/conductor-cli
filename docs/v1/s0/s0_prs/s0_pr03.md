# agency slice 00 / pr-03: persistence schemas + repo store (repo_index.json + repo.json)

## goal
define the on-disk schemas and implement atomic persistence for:
- `${AGENCY_DATA_DIR}/repo_index.json`
- `${AGENCY_DATA_DIR}/repos/<repo_id>/repo.json`

this PR adds a small storage module that can read/update/write these files via atomic rename. it must not wire into `agency doctor` yet; persistence is exercised only by unit/integration tests in this PR.

## scope
in scope:
- go structs representing `repo_index.json` and `repo.json` schemas (public contract v1)
- load/create/update/save functions:
  - read existing json if present; if missing treat as empty
  - update in-memory data and write back atomically
- path helpers for:
  - `${AGENCY_DATA_DIR}/repo_index.json`
  - `${AGENCY_DATA_DIR}/repos/<repo_id>/repo.json`
- store timestamps in RFC3339 (UTC) strings (stable + human-readable)
- ensure directories exist for repo.json writes (`.../repos/<repo_id>/`)
- use `WriteFileAtomic` for json writes

out of scope (hard):
- calling these from `agency doctor`
- creating runs, meta.json, events.jsonl
- any worktrees/tmux/scripts execution
- any external commands
- any network calls

## public surface area
none (internal only).

## schema: repo_index.json (v1)
file: `${AGENCY_DATA_DIR}/repo_index.json`

purpose: map stable `repo_key` to repo_id and track seen local paths.

json shape (exact):
```json
{
  "schema_version": "1.0",
  "repos": {
    "github:owner/repo": {
      "repo_id": "a1b2c3d4e5f6a7b8",
      "paths": ["/abs/path/to/repo", "/other/path"],
      "last_seen_at": "2026-01-09T00:00:00Z"
    },
    "path:<sha256>": {
      "repo_id": "deadbeefcafebabe",
      "paths": ["/abs/path/to/repo"],
      "last_seen_at": "2026-01-09T00:00:00Z"
    }
  }
}

rules:
	•	keys of repos are repo_key strings as produced by pr-01
	•	repo_id is derived (sha256(repo_key) truncated to 16 hex chars) and stored redundantly
	•	paths:
	•	always absolute, cleaned
	•	de-duplicated
	•	order: most-recent-first (optional but recommended). if you keep append-only order, lock it and test it.
	•	timestamps:
	•	RFC3339 UTC with time.RFC3339

schema: repo.json (v1)

file: ${AGENCY_DATA_DIR}/repos/<repo_id>/repo.json

purpose: per-repo record for last known state and capabilities.

json shape (exact):

{
  "schema_version": "1.0",
  "repo_key": "github:owner/repo",
  "repo_id": "a1b2c3d4e5f6a7b8",
  "repo_root_last_seen": "/abs/path/to/repo",
  "agency_json_path": "/abs/path/to/repo/agency.json",

  "origin_present": true,
  "origin_url": "git@github.com:owner/repo.git",
  "origin_host": "github.com",
  "capabilities": {
    "github_origin": true,
    "origin_host": "github.com",
    "gh_authed": true
  },

  "created_at": "2026-01-09T00:00:00Z",
  "updated_at": "2026-01-09T00:00:00Z"
}

rules:
	•	origin_* fields:
	•	if origin missing: origin_present=false, origin_url=””, origin_host=””
	•	created_at set on first write, never changes
	•	updated_at updated on each successful doctor later (but this PR only provides API)

APIs to implement (internal)

create package internal/store with:

type RepoIndex struct {
  SchemaVersion string                   `json:"schema_version"`
  Repos         map[string]RepoIndexEntry `json:"repos"`
}
type RepoIndexEntry struct {
  RepoID      string   `json:"repo_id"`
  Paths       []string `json:"paths"`
  LastSeenAt  string   `json:"last_seen_at"`
}

type RepoRecord struct {
  SchemaVersion       string `json:"schema_version"`
  RepoKey             string `json:"repo_key"`
  RepoID              string `json:"repo_id"`
  RepoRootLastSeen    string `json:"repo_root_last_seen"`
  AgencyJSONPath      string `json:"agency_json_path"`
  OriginPresent       bool   `json:"origin_present"`
  OriginURL           string `json:"origin_url"`
  OriginHost          string `json:"origin_host"`
  Capabilities        struct {
    GitHubOrigin bool   `json:"github_origin"`
    OriginHost   string `json:"origin_host"`
    GhAuthed     bool   `json:"gh_authed"`
  } `json:"capabilities"`
  CreatedAt           string `json:"created_at"`
  UpdatedAt           string `json:"updated_at"`
}

type Store struct {
  FS      fs.FS           // your interface from pr-00 (name it so it doesn’t collide with io/fs)
  DataDir string          // resolved AGENCY_DATA_DIR
  Now     func() time.Time // injectable clock for tests (required)
}

func NewStore(fsys fs.FS, dataDir string, now func() time.Time) *Store

// Paths:
func (s *Store) RepoIndexPath() string
func (s *Store) RepoDir(repoID string) string
func (s *Store) RepoRecordPath(repoID string) string

// Index operations:
func (s *Store) LoadRepoIndex() (RepoIndex, error)
func (s *Store) UpsertRepoIndexEntry(idx RepoIndex, repoKey, repoID, absPath string) RepoIndex
func (s *Store) SaveRepoIndex(idx RepoIndex) error

// Repo record operations:
func (s *Store) LoadRepoRecord(repoID string) (RepoRecord, bool, error) // bool=exists
func (s *Store) BuildRepoRecord(input BuildRepoRecordInput) RepoRecord
func (s *Store) SaveRepoRecord(rec RepoRecord) error

input struct:

type BuildRepoRecordInput struct {
  RepoKey        string
  RepoID         string
  RepoRootLastSeen string
  AgencyJSONPath string
  OriginPresent  bool
  OriginURL      string
  OriginHost     string
  Capabilities struct {
    GitHubOrigin bool
    OriginHost   string
    GhAuthed     bool
  }
}

behavior requirements:
	•	LoadRepoIndex:
	•	if file missing -> return empty index with schema_version “1.0” and empty map
	•	if missing/invalid schema_version -> return E_STORE_CORRUPT with filename
	•	if invalid json -> return E_STORE_CORRUPT (new code) with filename + wrapped parse error
	•	SaveRepoIndex:
	•	ensure ${AGENCY_DATA_DIR} exists (mkdirall)
	•	marshal with indentation for human readability (no stable key order with maps)
	•	atomic write via WriteFileAtomic
	•	file perm 0644
	•	UpsertRepoIndexEntry:
	•	create entry if missing; set last_seen_at = now
	•	always update last_seen_at = now
	•	update paths:
	•	normalize absPath with filepath.Clean
	•	if already present: move to index 0
	•	else insert at index 0
	•	de-dupe case-sensitively
	•	LoadRepoRecord:
	•	if missing -> (zero, false, nil)
	•	if missing/invalid schema_version -> E_STORE_CORRUPT
	•	if invalid json -> E_STORE_CORRUPT with wrapped parse error
	•	UpsertRepoRecord:
	•	if record existed previously, preserves CreatedAt and updates UpdatedAt
	•	else sets both to now

func (s *Store) UpsertRepoRecord(existing *RepoRecord, input BuildRepoRecordInput) RepoRecord

which:
	•	if existing != nil: preserves CreatedAt, updates UpdatedAt
	•	else sets both to now

	•	SaveRepoRecord:
	•	mkdirall repo dir
	•	atomic write
	•	perm 0644

error codes

introduce one new code for persistence:
	•	E_STORE_CORRUPT — malformed json or unreadable schema in repo_index/repo.json

(do not add more store codes in this PR.)

atomicity guarantees
	•	JSON writes use temp file + rename (already implemented).
	•	No partial files should exist after success.
	•	On write failure, original file must remain unchanged.

tests

unit tests (required)
	1.	repo_index roundtrip:

	•	start with missing file -> Load yields empty
	•	upsert entry -> save -> load -> equals expected (schema_version, repo_id, paths, timestamps)
	•	upsert same path again -> no duplication
	•	upsert new path -> added

	2.	repo_record upsert:

	•	create new record -> created_at == updated_at == now
	•	upsert existing with later now -> created_at unchanged, updated_at updated
	•	capabilities preserved from input

	3.	corrupt json:

	•	write invalid JSON into repo_index.json -> LoadRepoIndex returns E_STORE_CORRUPT
	•	same for repo.json

integration-style test (temp dir, real FS impl)
	•	create Store with dataDir under t.TempDir()
	•	SaveRepoIndex and SaveRepoRecord create expected directories/files
	•	missing parent dir for repo_record is created

test constraints:
	•	tests must not require any external tools installed.
	•	use injected clock for deterministic timestamps.

acceptance
	•	go test ./... passes
	•	no CLI behavior changes besides compiling
	•	store code is not yet invoked by agency doctor (that’s pr-05)

guardrails
	•	do not add doctor/init wiring
	•	do not add run meta/events storage
	•	do not add worktrees/tmux/scripts execution
	•	do not add third-party deps
