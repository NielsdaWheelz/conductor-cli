# agency slice 00 / pr-05: `agency doctor` (checks + output + persistence-on-success)

## goal
implement `agency doctor` as a strict, deterministic readiness check for v1 that:
- validates repo + `agency.json`
- verifies required tools + `gh auth status`
- resolves runner + scripts
- prints stable parseable output
- writes/updates `${AGENCY_DATA_DIR}/repo_index.json` and `${AGENCY_DATA_DIR}/repos/<repo_id>/repo.json` **only on full success**

this PR must be narrowly scoped to **doctor only**.

---

## scope

### in scope
- add `agency doctor` command implementation + wiring (no flags in v1)
- repo discovery via `git rev-parse --show-toplevel`
- load + strict validate `agency.json` (schema v1) using existing config module
- compute repo identity + origin status:
  - parse origin url if present
  - determine `repo_key` (`github:<owner>/<repo>` if github.com ssh/https; else `path:<sha256(abs_path)>`)
  - compute `repo_id = sha256(repo_key)` truncated (use existing helper)
  - determine:
    - `origin_present` (bool)
    - `origin_url` (string, empty if missing)
    - `origin_host` (string, empty if missing or unparsable)
    - `github_flow_available` (bool) = `origin_host == "github.com"` AND origin url parseable into owner/repo
- prerequisites checks (strict):
  - `git --version` else `E_GIT_NOT_INSTALLED`
  - `tmux -V` else `E_TMUX_NOT_INSTALLED`
  - `gh --version` else `E_GH_NOT_INSTALLED`
  - `gh auth status` else `E_GH_NOT_AUTHENTICATED`
- runner resolution + existence check:
  - determine runner command for `defaults.runner` using `agency.json.runners` if present; else PATH fallback only if defaults.runner is `claude|codex`
  - verify runner executable exists on PATH (or is absolute/relative path that exists+executable)
  - if not found: `E_RUNNER_NOT_CONFIGURED`
  - **v1 constraint:** runner command must be a single executable token (no args). if config contains spaces, treat as invalid config (`E_INVALID_AGENCY_JSON`) with message “runner commands must not include args in v1”
- script checks (no execution):
  - resolve `scripts.setup|verify|archive` paths
  - if relative path: resolve relative to repo root
  - if missing: `E_SCRIPT_NOT_FOUND`
  - if not executable: `E_SCRIPT_NOT_EXECUTABLE` with chmod hint
- output contract:
  - stdout: stable `key: value` lines (exact keys defined below)
  - stderr: errors only
- persistence on success only:
  - write/update repo_index.json
  - write/update repo.json
  - atomic write via temp file + rename

### explicitly out of scope
- worktrees, tmux session creation, script execution
- run state files: no run meta/events
- any PR/push/merge behavior
- any network calls beyond `gh auth status` (gh may internally hit network; we just run the command)
- any lock implementation (keep in later slice unless already required by your architecture)

---

## public surface area

### command
- `agency doctor`

### error codes used (must already exist)
- `E_NO_REPO`
- `E_NO_AGENCY_JSON`
- `E_INVALID_AGENCY_JSON`
- `E_GIT_NOT_INSTALLED`
- `E_TMUX_NOT_INSTALLED`
- `E_GH_NOT_INSTALLED`
- `E_GH_NOT_AUTHENTICATED`
- `E_RUNNER_NOT_CONFIGURED`
- `E_SCRIPT_NOT_FOUND`
- `E_SCRIPT_NOT_EXECUTABLE`
- plus generic filesystem/exec wrapper code you already use

(no new codes in this PR.)

### files written (on success only)
- `${AGENCY_DATA_DIR}/repo_index.json`
- `${AGENCY_DATA_DIR}/repos/<repo_id>/repo.json`

---

## required behavior

### repo discovery
- if not in git repo: `E_NO_REPO`
- repo root is canonicalized for hashing (use your existing normalization)

### agency.json validation
- require `<repo_root>/agency.json` exists: else `E_NO_AGENCY_JSON`
- validate strictly: else `E_INVALID_AGENCY_JSON` and print the first validation error
- enforce v1 rule: runner commands are single-token executables (no args)

### tool checks
use `CommandRunner` for external commands (stub-friendly), with:
- `git --version`
- `tmux -V`
- `gh --version`
- `gh auth status`

rules:
- if command not found or exit != 0: fail with appropriate code
- capture versions from stdout (trim whitespace). do not parse beyond “a stable line string”.

### runner command existence check
- after resolving runner command string (single token), verify it exists:
  - if absolute or relative path: check `Stat` + executable bit
  - else: use `exec.LookPath` (this is fine for v1)
- if missing: `E_RUNNER_NOT_CONFIGURED`

### scripts checks
for each script path in config:
- resolve absolute path:
  - if path is absolute: use as-is
  - else: `filepath.Join(repo_root, script_path)`
- must exist: else `E_SCRIPT_NOT_FOUND`
- must be executable: else `E_SCRIPT_NOT_EXECUTABLE` with hint `chmod +x <script_path>`

### output format (stdout)
print stable key/value lines, one per line, `key: value`.

exact keys (v1), in this order:

repo + dirs:
- `repo_root: <abs path>`
- `agency_data_dir: <abs path>`
- `agency_config_dir: <abs path>`
- `agency_cache_dir: <abs path>`

identity/origin:
- `repo_key: <string>`
- `repo_id: <string>`
- `origin_present: true|false`
- `origin_url: <string>` (empty allowed)
- `origin_host: <string>` (empty allowed)
- `github_flow_available: true|false`

tooling:
- `git_version: <string>`
- `tmux_version: <string>`
- `gh_version: <string>`
- `gh_authenticated: true` (only printed on success; if unauthenticated, command fails)

config resolution:
- `defaults_parent_branch: <string>`
- `defaults_runner: <string>`
- `runner_cmd: <string>` (resolved command used)
- `script_setup: <string>` (resolved absolute path)
- `script_verify: <string>`
- `script_archive: <string>`

final:
- `status: ok`

notes:
- do not print extra commentary on success.
- for errors, print a single-line error message on stderr (plus optional “hint:” line). keep stdout empty on failure.

### persistence (success only)
only after all checks pass:
1) ensure `${AGENCY_DATA_DIR}/repos/<repo_id>/` exists
2) write/update `repo_index.json`
3) write/update `repos/<repo_id>/repo.json`

**repo_index.json** (schema v1):
- top-level object with:
  - `schema_version: "1.0"`
  - `repos: { "<repo_key>": { "repo_id": "<repo_id>", "paths": ["..."], "last_seen_at": "<rfc3339>" } }`
- merge behavior:
  - if repo_key exists: add repo_root to `paths` if missing, update `last_seen_at`
  - if new: create entry with `paths=[repo_root]`
- maintain `paths` as unique strings, preserve existing order, append new at end

**repo.json** (schema v1):
- top-level fields:
  - `schema_version: "1.0"`
  - `repo_key`, `repo_id`
  - `root_path` (repo_root)
  - `agency_json_path` (abs path)
  - `origin_present` (bool)
  - `origin_url` (string)
  - `origin_host` (string)
  - `github_flow_available` (bool)
  - `created_at` (rfc3339, set on first write only)
  - `last_seen_at` (rfc3339, update each success)

atomic writes:
- write to temp file in same directory + rename
- do not write any json files if any check fails

---

## files to create/modify

expected additions (adjust to match your tree):
- `internal/commands/doctor.go` — command entrypoint
- `internal/doctor/doctor.go` or `internal/doctor/checks.go` — orchestration
- `internal/doctor/output.go` — output formatting and ordering
- `internal/doctor/persist.go` — persistence calls to store layer
- `internal/cli/dispatch.go` — wire subcommand

use existing modules for:
- paths resolution
- repo discovery
- origin parsing
- config loading/validation
- store layer (repo_index/repo.json) + atomic writes

avoid touching init.

---

## tests

### unit tests (required)

1) output formatting golden test
- build a `DoctorReport` struct and ensure output lines match expected order and keys.
- store expected output in `testdata/doctor_ok.golden`.

2) failure: unauthenticated gh
- stub CommandRunner:
  - `git --version` ok
  - `tmux -V` ok
  - `gh --version` ok
  - `gh auth status` exit non-zero
- ensure:
  - returns `E_GH_NOT_AUTHENTICATED`
  - **no json files written**

3) failure: missing scripts / non-executable scripts
- stub FS for Stat/Mode checks (or real temp FS) to simulate missing/non-exec
- ensure correct code + chmod hint for non-exec

4) success writes persistence
- run doctor with:
  - temp repo root (real folder)
  - agency.json present and valid
  - stub CommandRunner all ok
  - stub origin present/missing variants
- assert:
  - repo_index.json created and contains repo_key entry
  - repo.json created with correct fields
  - created_at stable across second run (run twice; created_at unchanged, last_seen_at updated)
  - paths uniqueness maintained

5) origin missing still succeeds
- simulate missing origin url
- assert `github_flow_available: false` and repo_key falls back to path key

### integration-style (recommended)
- create a temp git repo (`git init`), write `agency.json` + scripts with exec bit
- stub CommandRunner for gh/tmux (so test doesn’t depend on host)
- run doctor handler and verify persistence + output

---

## guardrails
- do not create worktrees / tmux sessions / run files
- do not execute scripts
- do not write any `${AGENCY_DATA_DIR}` json unless doctor completes successfully
- no new flags for doctor in v1
- keep stdout parseable and stable; no emojis/ascii art; no extra chatter

---

## how to run
- `go test ./...`

---

## claude prompt pack (for implementation)

implement **slice 00 pr-05** only: `agency doctor`.

constraints:
- strict checks per spec
- stable stdout `key: value` lines in the defined order
- write repo_index.json + repo.json only on success (atomic)
- no scope creep into runs/worktrees/tmux sessions/scripts execution

commands:
- `go test ./...`

deliverables:
- working `agency doctor`
- tests passing
- no regression to `agency init`