# agency s2 pr-06 spec: transcript capture + ansi stripping + `show --capture` + events.jsonl (+ final slice integration check)

## goal
implement deterministic tmux transcript capture and minimal per-run event logging for `agency show <id> --capture`, without breaking `show` when capture fails.

after this PR:
- `agency show <id> --capture` (mutating) will:
  - take the repo lock
  - emit `cmd_start`/`cmd_end` to `events.jsonl`
  - best-effort capture full tmux scrollback, strip ANSI, rotate and write transcript files
  - still show run details even if capture fails

## non-goals
- no new top-level commands
- no global expansion of events emission beyond **`show --capture`** (other commands remain unchanged in s2)
- no live/continuous recording
- no replay/resume transcript streaming
- no `gh` calls (no network)
- no runner pid inspection (`tmux_active` remains “tmux session exists”)
- no changes to `agency.json`, `meta.json`, discovery/indexing, or status derivation logic

---

## public surface area

### command change
`agency show <id>`

### new flag (must exist)
- `--capture`:
  - mutating mode (takes repo lock and emits events)
  - captures tmux scrollback to transcript files best-effort, then prints the normal `show` output

### behavior lock-in
- `show` without `--capture` remains strictly read-only (no lock, no events)
- `show --capture` must **never** fail the command solely because capture/events failed; it warns and continues
- if the repo lock cannot be acquired: `show --capture` fails with `E_REPO_LOCKED` (non-zero) and does not emit events

---

## persistence contract

### transcript files (write, best-effort)
location is per-run global run dir:
- `run_dir = ${AGENCY_DATA_DIR}/repos/<repo_id>/runs/<run_id>/`

writes on `show --capture`:
- `<run_dir>/transcript.txt` (overwrite)
- `<run_dir>/transcript.prev.txt` (single backup; best-effort rotate)

rotation + atomic write rule:
1. if `transcript.txt` exists:
   - best-effort rename/move to `transcript.prev.txt` (overwrite prev if present)
2. write new content to `transcript.txt.tmp`
3. rename `transcript.txt.tmp` to `transcript.txt` (atomic on same filesystem)

### events file (append, best-effort)
- `<run_dir>/events.jsonl` (append-only; create lazily)

schema (each line is one JSON object):
```json
{
  "schema_version": "1.0",
  "timestamp": "rfc3339",
  "repo_id": "...",
  "run_id": "...",
  "event": "cmd_start|cmd_end",
  "data": {}
}

minimum data fields:
	•	for cmd_start: { "cmd": "show", "args": ["..."] }
	•	for cmd_end: { "cmd": "show", "exit_code": 0, "duration_ms": 123, "error_code": null }

notes:
	•	error_code in cmd_end is optional; if present, it must be E_*
	•	args are recorded exactly as seen by the command handler (e.g., os.Args[1:] or parsed args in stable order)
	•	capture failures must not set a non-zero command exit; instead:
	•	print warnings to stderr (human output)
	•	in --json mode, add fields to data:
	•	{ "capture_ok": false, "capture_stage": "has_session|capture_pane|strip_ansi|rotate|write", "capture_error": "..." }

## tmux capture contract

target selection (locked)

capture targets the primary runner pane:
	•	session name: agency:<run_id>
	•	assume single window/pane created by agency
	•	target string: agency:<run_id>:0.0

capture command:
	•	tmux capture-pane -p -S - -t <target>

session existence check:
	•	tmux has-session -t agency:<run_id> (exit 0 => exists)

failure rules (locked)
	•	if session missing: warn “no tmux session; transcript not captured” and continue
	•	do not write any transcript files when session is missing (no placeholders)
	•	if capture-pane fails: warn and continue
	•	if tmux binary missing or server not running: warn and continue (treat as session missing)
	•	if writing transcript fails: warn and continue
	•	if ANSI stripping panics/errors: recover, warn, and write unstripped text if available (best-effort)
	•	warnings go to stderr; no warnings on stdout when --json or --path

ANSI stripping (locked)
	•	strip ANSI escape sequences after capture (operate on captured string)
	•	stripping is a pure function, table-tested
	•	must be total and never panic
	•	must remove all ESC (\x1b) sequences (CSI, OSC, etc.)

## lock + events emission rules

agency show --capture is mutating:
	•	it must acquire the repo lock for the run’s repo_id using internal/lock from pr-00
	•	if lock acquisition fails with ErrLocked: return E_REPO_LOCKED and do not emit events
	•	it must emit cmd_start at the beginning of the locked section (best-effort)
	•	it must emit cmd_end at the end (best-effort), even if capture failed
	•	after lock acquired:
	•	append cmd_start (ignore failure)
	•	defer append cmd_end with duration + capture_ok (ignore failure)
	•	run capture flow

read-only show (no --capture) must:
	•	not take the lock
	•	not emit events

⸻

files to create/modify (exact)

create
	•	internal/tmux/ansi.go
	•	func StripANSI(s string) string (pure; must not panic)
	•	internal/tmux/capture.go
	•	must not call os/exec directly from command code; provide a small executor interface (see below)
	•	internal/events/append.go
	•	type Event struct { SchemaVersion, Timestamp, RepoID, RunID, Event string; Data map[string]any }
	•	func AppendEvent(path string, e Event) error (append one JSON line; create file lazily)

modify
	•	cmd/agency/show.go
	•	add --capture
	•	when flag set:
	•	acquire lock
	•	emit events
	•	run capture flow
	•	then proceed to normal show rendering (human/json/path still work)

do not modify agency ls in this PR.

⸻

exact APIs (locked)

tmux executor interface

create an internal interface to mock in tests:

// internal/tmux/capture.go
package tmux

type Executor interface {
	// Run executes a command and returns stdout, stderr, and exit code.
	Run(name string, args ...string) (stdout string, stderr string, exitCode int, err error)
}

func HasSession(exec Executor, session string) bool
func CaptureScrollback(exec Executor, target string) (string, error)

conventions:
	•	HasSession uses tmux has-session -t <session>
	•	CaptureScrollback uses tmux capture-pane -p -S - -t <target>
	•	caller (show) constructs:
	•	session = agency:<run_id>
	•	target  = agency:<run_id>:0.0
	•	err means failure to start/execute (e.g., binary missing)
	•	non-zero exit is represented by exitCode != 0 (err may be nil)
	•	HasSession returns true iff exitCode == 0
	•	CaptureScrollback returns error if exitCode != 0 or err != nil (include stderr)
	•	show treats HasSession/CaptureScrollback errors as warnings, not fatal

events append

// internal/events/append.go
package events

type Event struct {
	SchemaVersion string                 `json:"schema_version"`
	Timestamp     string                 `json:"timestamp"`
	RepoID        string                 `json:"repo_id"`
	RunID         string                 `json:"run_id"`
	Event         string                 `json:"event"`
	Data          map[string]any         `json:"data,omitempty"`
}

func AppendEvent(path string, e Event) error

requirements:
	•	append one line per call
	•	line must end with \n
	•	JSON must be compact (default encoder ok), no indentation

show wiring
	•	implement capture flow only when --capture is set
	•	--capture must work with --json and --path:
	•	capture happens first (best-effort)
	•	then output mode is applied as usual

⸻

behaviors (given/when/then)

capture success path
	•	given: tmux session agency:<run_id> exists
	•	when: agency show <id> --capture
	•	then:
	•	acquires repo lock
	•	appends cmd_start to events.jsonl
	•	captures full scrollback from agency:<run_id>:0.0
	•	strips ANSI
	•	rotates transcript files and writes transcript.txt
	•	appends cmd_end to events.jsonl
	•	prints normal show output

lock contention
	•	given: repo lock is held by another process
	•	when: agency show <id> --capture
	•	then: exits non-zero E_REPO_LOCKED and emits no events

session missing
	•	given: tmux session does not exist
	•	when: agency show <id> --capture
	•	then:
	•	emits events (best-effort)
	•	prints warning about missing session
	•	does not write transcript files
	•	still prints normal show output
	•	exits 0

tmux capture failure
	•	given: session exists but capture-pane fails
	•	then: warn and still show; events still appended; exit 0

events append failure
	•	given: file is unwritable
	•	then: warn and continue; capture may still proceed; exit 0

rotation behavior
	•	given: transcript.txt exists
	•	when: show –capture runs and capture returns “new”
	•	then:
	•	transcript.prev.txt becomes the old transcript (best-effort)
	•	transcript.txt contains the new transcript

⸻

tests (must exist)

unit tests
	1.	StripANSI table tests

	•	inputs:
	•	plain text
	•	text with color codes (\x1b[31mred\x1b[0m)
	•	cursor movement codes
	•	malformed sequences
	•	assert:
	•	output contains no \x1b bytes
	•	function never panics

	2.	tmux command formatting (mock Executor)

	•	HasSession calls tmux has-session -t agency:<id>
	•	CaptureScrollback calls tmux capture-pane -p -S - -t agency:<id>:0.0

	3.	events append creates + appends

	•	write two events, assert:
	•	file exists
	•	contains 2 newline-delimited JSON objects
	•	each parses as Event and has required fields

	4.	transcript rotation filesystem test

	•	create run_dir with transcript.txt = “old”
	•	run rotation helper (invoke show capture path with stubbed tmux output “new”)
	•	assert:
	•	transcript.prev.txt == “old”
	•	transcript.txt == “new” (ANSI stripped)
	•	transcript.txt.tmp does not remain

integration-ish test (light, no binary exec)
	•	create temp ${AGENCY_DATA_DIR} with one valid run meta + run_dir
	•	create fake worktree + report file as needed for show
	•	run show handler with --capture using mock tmux executor:
	•	case A: HasSession false -> exit 0, no transcript, events file exists with cmd_start/cmd_end
	•	case B: HasSession true, CaptureScrollback returns ANSI text -> transcript written stripped, events appended

test constraints:
	•	do not require real tmux installed
	•	do not require git repo present
	•	do not require network

⸻

guardrails
	•	capture failures must not block show
	•	do not emit events for ls or for show without --capture
	•	do not introduce any gh usage
	•	do not mutate meta.json or repo_index.json
	•	do not add new dependencies
	•	warnings must go to stderr; stdout remains clean for --json/--path

⸻

manual demo (acceptance)

# with an active run that has a tmux session
agency show <run_id> --capture
ls -la ${AGENCY_DATA_DIR}/repos/<repo_id>/runs/<run_id>/
cat ${AGENCY_DATA_DIR}/repos/<repo_id>/runs/<run_id>/transcript.txt | head
tail -n 2 ${AGENCY_DATA_DIR}/repos/<repo_id>/runs/<run_id>/events.jsonl

session missing case:

agency kill <run_id>   # if available from earlier slices
agency show <run_id> --capture
# should warn and still succeed


⸻

done criteria
	•	agency show --capture:
	•	takes repo lock
	•	emits cmd_start/cmd_end to events.jsonl (best-effort)
	•	captures tmux scrollback when session exists
	•	strips ANSI
	•	rotates transcript.txt -> transcript.prev.txt
	•	never fails show solely due to capture/events errors
	•	all tests added in this PR pass
	•	go test ./... passes

⸻

final integration check for slice 2 (post pr-06)

manual (must work)
	1.	current repo scoping:

	•	create 2 runs in current repo
	•	agency ls shows only those (exclude archived)
	•	agency ls --all includes archived

	2.	outside repo:

	•	cd /tmp
	•	agency ls lists across repos by default

	3.	ambiguous prefix:

	•	create two runs with same prefix collision
	•	agency show <ambiguous-prefix> returns E_RUN_ID_AMBIGUOUS and prints candidates

	4.	capture:

	•	with a tmux-backed run:
	•	agency show <id> --capture writes transcript files and appends events.jsonl

automated (minimum)
	•	one light integration test that builds a fake ${AGENCY_DATA_DIR} tree and asserts:
	•	agency ls --all-repos --all --json exits 0
	•	includes broken=true for corrupt meta
	•	includes expected run_ids
	•	plus the pr-06 integration-ish show --capture tests described above

⸻

claude prompt pack (execution)

commands

git status --porcelain
go test ./...

implement
	•	create files exactly as specified
	•	update cmd/agency/show.go to support --capture with lock + events + best-effort capture
	•	do not refactor unrelated code

verify

go test ./...

constraints (repeat)
	•	no gh calls
	•	no new deps
	•	do not emit events except for show --capture
	•	capture failures must not block show
