# agency s2 pr-00 spec: repo lock helper

## goal
add a single, testable repo-level lock primitive so all **mutating** commands can serialize writes to `${AGENCY_DATA_DIR}/repos/<repo_id>/...` without races.

## non-goals
- no command wiring
- no changes to `agency.json`, `meta.json`, `events.jsonl`
- no changes to run discovery, status, tmux, or rendering
- no network calls
- no global lock; **repo-level only**

## public surface area
none (internal-only go package).

## files to create
- `internal/lock/repo_lock.go`
- `internal/lock/repo_lock_test.go`

## lock contract

### lock path
lock file is a **file**, not a directory:

- `${AGENCY_DATA_DIR}/repos/<repo_id>/.lock`

(where `AGENCY_DATA_DIR` is resolved by existing helpers; this PR should accept a `dataDir` arg and not read env directly.)

### semantics
- **single-writer** per `repo_id`
- acquisition uses atomic file creation (`O_CREATE|O_EXCL`) so it works across processes (mac + linux)
- lock file contains **pid + created_at** (and optional fields for debugging)
- if lock exists:
  - read lock file content best-effort
  - if lock is **stale**, delete it and retry acquisition
  - else return a typed “locked” error (command layer will map to `E_REPO_LOCKED` later)
- lock does not block; it returns `ErrLocked` immediately

### stale detection (v1)
a lock is stale if **either**:
- `pid` is not alive, **or**
- `now - created_at > stale_after`

if the lock file is unreadable or `created_at` is missing/unparseable:
- compute age from `os.Stat(path).ModTime()` and apply the same stale_after rule

defaults for the helper:
- `stale_after = 2h`

(pid alive check must be pluggable for tests.)

### unlock
unlock removes the `.lock` file.
- unlock is idempotent: removing a missing file returns nil
- if remove fails, return error

## exact api (locked)

package: `internal/lock`

```go
package lock

import "time"

type LockInfo struct {
	PID       int       `json:"pid"`
	CreatedAt time.Time `json:"created_at"`
	Cmd       string    `json:"cmd,omitempty"`
}

// ErrLocked indicates a non-stale lock is held by someone else.
type ErrLocked struct {
	RepoID string
	Info   *LockInfo // nil if unreadable
	Path   string
}

func (e *ErrLocked) Error() string

type RepoLock struct {
	DataDir     string
	StaleAfter  time.Duration
	Now         func() time.Time
	IsPIDAlive  func(pid int) bool
}

// NewRepoLock returns a RepoLock with v1 defaults:
// - StaleAfter: 2h
// - Now: time.Now
// - IsPIDAlive: platform impl (best-effort)
func NewRepoLock(dataDir string) RepoLock

// Lock acquires the repo lock and returns an unlock function.
// - cmd is stored in the lock file for debugging (may be empty).
// - if already locked and not stale: returns *ErrLocked.
func (l RepoLock) Lock(repoID string, cmd string) (unlock func() error, err error)

### implementation notes (constraints)
	•	do not add third-party deps
	•	lock file format: json encoded LockInfo (write atomically)
	•	writing lock file must be atomic with acquisition:
	•	create with O_EXCL
	•	write json
	•	close fd
	•	create parent dir if missing: mkdir -p ${DATA}/repos/<repo_id>
	•	create lock file with permissions 0600
	•	stale handling must be race-safe:
	•	if stale -> remove -> retry loop (bounded retries, e.g. 3)
	•	retry only after removing a stale lock; do not retry on active contention
	•	ispidalive implementation can be best-effort:
	•	unix: os.FindProcess(pid) + process.Signal(0) pattern (handle errors conservatively)
	•	if pid check cannot be performed, treat as alive (do not steal lock solely on uncertainty)
	•	lock file creation is atomic, but contents may be partial on crash:
	•	if lock JSON is unreadable, treat as non-stale unless older than stale_after
	•	use os.Stat(path).ModTime() as fallback for age when JSON is unreadable or created_at missing

behaviors (given/when/then)

acquisition
	•	given: no .lock file for repo
	•	when: Lock(repoID, "push")
	•	then: returns unlock func and writes .lock with current pid and timestamp

contention
	•	given: lock file exists with pid alive and created_at within stale_after
	•	when: second goroutine/process calls Lock
	•	then: returns *ErrLocked (no waiting in helper)

(note: waiting/retry policy belongs to command layer, not this helper.)

stale lock
	•	given: lock file exists but pid dead
	•	when: Lock
	•	then: helper removes stale lock and acquires a new lock
	•	given: lock file exists and pid alive but created_at older than stale_after
	•	when: Lock
	•	then: helper treats as stale (removes and re-acquires)

unlock
	•	given: acquired lock
	•	when: unlock called
	•	then: .lock file removed
	•	given: unlock called twice
	•	then: second call returns nil

tests (must exist)

file: internal/lock/repo_lock_test.go

unit tests (table-driven where sensible)
	1.	writes lock file

	•	create temp datadir
	•	acquire lock
	•	assert .lock exists and json parses with pid/created_at set

	2.	errlocked on contention

	•	acquire lock with locker A
	•	attempt lock with locker B (same repo)
	•	assert error is *ErrLocked and repo id matches

	3.	stale-by-dead-pid steals

	•	write .lock manually with pid=999999 and old timestamp
	•	locker uses IsPIDAlive stub returning false
	•	assert lock acquisition succeeds

	4.	stale-by-age steals

	•	write .lock with pid alive stub true but created_at = now - (stale_after + 1s)
	•	assert lock acquisition succeeds

	4b.	unreadable lock file handling (mtime fallback)

	•	write .lock with garbage bytes and set mtime to now (recent)
	•	assert Lock returns ErrLocked (conservative)
	•	write .lock with garbage bytes and set mtime to now - (stale_after + 1s)
	•	assert lock acquisition succeeds

	5.	unlock idempotent

	•	acquire lock
	•	call unlock twice
	•	assert no error and .lock absent

	6.	parent dir creation

	•	temp datadir with no repos/<repo_id> directory
	•	call Lock(repoID)
	•	assert directory exists and lock acquired

concurrency sanity test (no flakes)
	•	acquire lock with locker A
	•	in goroutine, attempt lock with locker B and assert it returns ErrLocked quickly (no sleeps; use a channel + short timeout)

guardrails
	•	do not modify any command code under cmd/agency/* in this PR
	•	do not touch store/status/render/tmux/events packages
	•	do not introduce new error codes in this PR (command layer will map ErrLocked → E_REPO_LOCKED later)

demo

go test ./... -run RepoLock

done checklist
	•	go test ./... passes
	•	lock path is exactly ${AGENCY_DATA_DIR}/repos/<repo_id>/.lock
	•	parent dir is created on lock acquisition if missing
	•	lock file permissions are 0600
	•	helper returns *ErrLocked for non-stale contention
	•	stale logic (including unreadable JSON mtime fallback) is implemented and covered by tests
