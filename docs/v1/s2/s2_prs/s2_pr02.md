# agency s2 pr-02 spec: run id resolution (exact + unique prefix)

## goal
allow all run-targeting commands to accept either an **exact run_id** or a **unique prefix** of run_id, with deterministic resolution and deterministic error payloads.

this PR is a pure library change: no CLI wiring, no store scanning changes.

---

## non-goals
- no command wiring (no changes under `cmd/agency/*`)
- no filesystem scanning
- no status derivation
- no `gh` calls
- no mutation of any persisted files
- no “repair” logic
- no accepting aliases (branch names, PR numbers) in v1

---

## public surface area
none (internal-only go package).

---

## files to create
- `internal/ids/resolve.go`
- `internal/ids/resolve_test.go`

---

## contract: id resolution

### inputs
resolution operates over a set of candidate runs already discovered (from `store.Scan...` in pr-01). it must work across repos.
command layer should convert discovered runs into `[]RunRef` for resolution.

### resolution rules (locked)
given `input` and candidate run_ids:

1) **exact match wins**
- if exactly one candidate has `RunID == input`, resolve to that candidate.
- if exact matches >1 (same RunID across repos), treat as ambiguous.

2) otherwise, treat `input` as a prefix:
- collect all candidates where `strings.HasPrefix(RunID, input)` is true
- if 0 matches: not found
- if 1 match: resolve
- if >1 matches: ambiguous (return candidates)

3) input normalization:
- trim whitespace
- if empty after trim: return not found

### determinism
- ambiguous candidate lists must be returned in deterministic order:
  - sort by `RunID` ascending lexicographic
  - tie-break by `RepoID` ascending
  - stable sort not required

### broken runs
resolver must not refuse broken runs. it returns the resolved ref including `Broken` so the **command layer** can decide whether to error (e.g. `show` -> `E_RUN_BROKEN` later).

---

## exact API (locked)

package: `internal/ids`

```go
package ids

type RunRef struct {
	RepoID  string
	RunID   string
	Broken  bool
}

// ErrNotFound indicates no matching run_id (exact or prefix).
type ErrNotFound struct {
	Input string
}
func (e *ErrNotFound) Error() string

// ErrAmbiguous indicates prefix matched multiple run_ids.
type ErrAmbiguous struct {
	Input      string
	Candidates []RunRef // ordered deterministically
}
func (e *ErrAmbiguous) Error() string

// ResolveRunRef resolves an input run identifier to a single run reference.
// - exact match wins
// - otherwise unique prefix match
func ResolveRunRef(input string, refs []RunRef) (RunRef, error)

notes:
	•	do not add third-party deps
	•	keep errors as typed errors; command layer will map ErrAmbiguous -> E_RUN_ID_AMBIGUOUS later
	•	do a single pass; collect matches in a slice (no maps unless needed)
	•	command layer prints RunID list; may include RepoID for disambiguation

⸻

behaviors (given/when/then)

exact match wins
	•	given: runs include 20260110-a3f2 and 20260110-a3ff
	•	when: resolve input 20260110-a3f2
	•	then: resolves to that run, not ambiguous

unique prefix resolves
	•	given: only run 20260110-a3f2
	•	when: resolve input 20260110-a3
	•	then: resolves to 20260110-a3f2

ambiguous prefix errors
	•	given: runs include 20260110-a3f2 and 20260110-a3ff
	•	when: resolve input 20260110-a3f
	•	then: returns *ErrAmbiguous with both candidates in deterministic order

not found errors
	•	given: runs include 20260110-a3f2
	•	when: resolve input does-not-exist
	•	then: returns *ErrNotFound

empty input
	•	given: runs include 20260110-a3f2
	•	when: resolve input "   "
	•	then: returns *ErrNotFound

broken flag preserved
	•	given: a RunRef{RepoID:"r1", RunID:"20260110-a3f2", Broken:true}
	•	when: resolve input 20260110-a3
	•	then: returned RunRef.Broken == true

⸻

tests (must exist)

file: internal/ids/resolve_test.go

table-driven unit tests

minimum cases:
	1.	exact match

	•	runs: 20260110-a3f2, 20260110-a3ff
	•	input: 20260110-a3f2
	•	expect: ok, RunID exact

	2.	unique prefix

	•	runs: 20260110-a3f2
	•	input: 20260110-a3
	•	expect: ok, resolves

	3.	ambiguous prefix

	•	runs: 20260110-a3f2, 20260110-a3ff
	•	input: 20260110-a3f
	•	expect: *ErrAmbiguous and candidates length 2
	•	assert deterministic ordering (RunIDs sorted)

	4.	not found

	•	runs: 20260110-a3f2
	•	input: 20260110-zzz
	•	expect: *ErrNotFound

	5.	exact wins over prefix ambiguity

	•	runs: 20260110-a3f2, 20260110-a3ff
	•	input: 20260110-a3ff
	•	expect: ok, resolves exact

	6.	broken preserved

	•	runs: one Broken=true
	•	input: prefix
	•	expect: returned RunRef.Broken=true

	7.	empty input

	•	runs: 20260110-a3f2
	•	input: "   "
	•	expect: *ErrNotFound

	8.	duplicate exact across repos

	•	runs: {RepoID:r1, RunID:x}, {RepoID:r2, RunID:x}
	•	input: x
	•	expect: *ErrAmbiguous (exact match not unique)

test constraints
	•	do not touch filesystem
	•	do not import cmd layer
	•	assertions should type-assert error types (errors.As)

⸻

guardrails
	•	no changes under cmd/agency/*
	•	no changes to internal/store/* scanning logic in this PR
	•	no new error codes in this PR (typed errors only)

⸻

demo

go test ./... -run ResolveRunRef


⸻

done checklist
	•	typed errors exist and are used (ErrNotFound, ErrAmbiguous)
	•	exact match precedence implemented
	•	ambiguous candidates are deterministically ordered
	•	tests cover empty input and duplicate exact run_id across repos
	•	tests cover 0/1/many and exact-vs-prefix precedence
	•	go test ./... passes
