# agency s2 pr-04 spec: `agency ls` (human + `--json`) + scope rules (no capture)

## goal
ship `agency ls` as a fast, local-only listing command with sane default scoping, stable JSON output, and derived status computed from local evidence only.

## non-goals
- no `gh` calls anywhere in `ls` (no network)
- no changes to `agency.json`, `meta.json`, `repo.json`, `repo_index.json` schemas
- no new indexes or caches; discovery remains filesystem scan
- no transcript capture (no tmux capture-pane)
- no meta/repo_index mutation (no `last_seen_at`, no “fixups”)
- no runner pid inspection (`tmux_active` == tmux session exists)
- no new commands; only `ls` flags/wiring

---

## public surface area

### command
`agency ls`

### flags (must exist)
- `--all` : include archived runs (worktree missing) for selected scope
- `--all-repos` : list runs across all repos (overrides “current repo only”)
- `--json` : machine output (stable envelope)

### default scope rules (locked)
- if **cwd is inside a git repo**: default scope = that repo only, excluding archived
- if **cwd is not inside any git repo**: default scope = all repos, excluding archived
- `--all-repos` forces all repos regardless of cwd
- `--all` includes archived in whichever scope is selected

### sorting (locked)
- sort by `created_at` descending (newest first)
- broken runs have `created_at = null` and sort **last**
- tie-breaker (when both timestamps equal or nil): lexicographic `run_id` ascending
note: created_at parsing failures are handled in scanning (pr-01) by marking broken.

---

## inputs and dependencies (must use existing helpers)
- repo root detection: reuse existing repo discovery helper (the one used by `init/doctor/run`) to determine whether cwd is in a git repo
- derive repo_id in-memory from repo_key (or path hash) without requiring repo.json; do not write repo.json/repo_index.json during `ls`
- run discovery: use `internal/store` scan functions from pr-01:
  - for current-repo scope: `store.ScanRunsForRepo(dataDir, repoID)`
  - for all-repos scope: `store.ScanAllRuns(dataDir)`
- status derivation: use `internal/status.Derive(meta, Snapshot)` from pr-03
- id resolution is **not** used in `ls` (that is for `show` and others)

---

## output contracts

### human output (locked fields + formatting constraints)
each row must contain:
- `run_id` (full string)
- `title` (truncate to 50 chars; if truncated append `…`)
- `runner` (empty for broken rows)
- `created_at` (human-friendly ok; e.g. relative; but must be stable-ish and not crash on null)
- `status` (derived string from `status.Derive`)
- `pr` (short: `#123` or empty)

broken-row human display rules:
- `title` = `<broken>`
- `runner` empty
- `created_at` empty
- `status` = `broken`
- `pr` empty
note: run_id must be the first column for easy copy/paste.

> note: human formatting can be simple whitespace columns; do not introduce third-party table libs.

### json output (must be stable + versioned)
`agency ls --json` must output exactly:

```json
{
  "schema_version": "1.0",
  "data": [ /* RunSummary[] */ ]
}

RunSummary fields (types locked)

type RunSummary = {
  run_id: string
  repo_id: string
  repo_key: string | null
  origin_url: string | null
  title: string               // "<broken>" for broken rows
  runner: string | null       // null for broken rows
  created_at: string | null   // RFC3339Nano; null for broken rows
  last_push_at: string | null // RFC3339Nano or null
  tmux_active: boolean
  worktree_present: boolean
  archived: boolean
  pr_number: number | null
  pr_url: string | null
  derived_status: string
  broken: boolean
}

json requirements:
	•	timestamps are RFC3339Nano (use time.Time.Format(time.RFC3339Nano))
	•	repo_key/origin_url are best-effort join from repo.json (if missing/corrupt, set null; do not mark run broken)
	•	broken=true only when meta.json is unreadable/invalid for that run

⸻

local evidence snapshot rules (for status + booleans)

filesystem snapshot inputs

for each run record (including broken where possible):
	•	worktree_present = os.Stat(meta.worktree_path) success (for broken rows, do not infer paths; set worktree_present=false and report_bytes=0)
	•	archived = !worktree_present
	•	report_bytes:
	•	if worktree_present: stat <worktree>/.agency/report.md and set bytes; else 0
	•	tmux_active:
	•	call tmux at most once per invocation: `tmux list-sessions -F '#S'`
	•	build a set of session names; tmux_active = sessions["agency:"+run_id]
	•	if tmux is missing or server not running, treat tmux_active=false for all runs (no error)

status derivation
	•	for non-broken runs: call status.Derive(meta, Snapshot{TmuxActive, WorktreePresent, ReportBytes})
	•	for broken runs:
	•	derived_status must be "broken"
	•	tmux_active should still be computed from session existence (single list-sessions call)
	•	title must be <broken>
	•	derived_status for non-broken rows must come only from status.Derive (no duplicated logic)

title fallback
	•	if meta.title is empty, human output shows `<untitled>`
	•	json output preserves the raw title string (empty ok)

⸻

persistence (must not write)

ls must be strictly read-only:
	•	must not create or modify:
	•	${AGENCY_DATA_DIR}/repo_index.json
	•	${AGENCY_DATA_DIR}/repos/<repo_id>/repo.json
	•	${AGENCY_DATA_DIR}/repos/<repo_id>/runs/<run_id>/meta.json
	•	any events.jsonl
	•	any <worktree>/.agency/*

⸻

files to create/modify (exact)

create
	•	internal/render/ls.go
	•	func RenderLSHuman(w io.Writer, rows []RunSummaryHumanRow) error (or similar)
	•	keep it dumb: formatting only
	•	internal/render/json.go
	•	define RunSummary struct + envelope struct for ls output
	•	helper to marshal with stable field names (json tags)

modify / add
	•	cmd/agency/ls.go (or existing command wiring location)
	•	parse flags
	•	resolve scope rules
	•	load runs via store
	•	compute snapshot booleans
	•	derive statuses
	•	output either human or json

constraint: do not rename/move existing command framework files. follow repo’s existing CLI style (cobra/urfave/etc.) exactly.

⸻

behaviors (given/when/then)

scope rules
	•	given: cwd inside repo A
	•	when: agency ls
	•	then: lists only runs where repo_id == repoA.repo_id, excluding archived
	•	given: cwd inside repo A
	•	when: agency ls --all
	•	then: lists repo A runs including archived
	•	given: cwd inside repo A
	•	when: agency ls --all-repos
	•	then: lists runs across all repos, excluding archived
	•	given: cwd not inside any git repo
	•	when: agency ls
	•	then: lists runs across all repos, excluding archived
	•	given: cwd not inside any git repo
	•	when: agency ls --all
	•	then: lists runs across all repos including archived

broken runs
	•	given: one run has corrupt meta.json
	•	when: agency ls --all-repos --json
	•	then: output includes that run with:
	•	broken=true
	•	run_id = directory name under runs/<run_id>/
	•	title="<broken>"
	•	created_at=null
	•	and: exit code is 0

sorting
	•	given: runs with created_at A > B
	•	when: agency ls --json
	•	then: A appears before B
	•	given: broken run (created_at null)
	•	then: appears after all non-broken runs

⸻

tests (must exist)

unit tests (table-driven)
	1.	scope selection

	•	simulate “in repo” vs “not in repo” by stubbing the repo-detection helper (or by passing an explicit cwdInRepo bool into a pure helper)
	•	assert selected mode is:
	•	in repo => repo-only unless --all-repos
	•	out of repo => all-repos by default

	2.	sorting

	•	create synthetic summaries with timestamps and ensure ordering rules
	•	do not assert human-relative time strings; test ordering on timestamps only

	3.	json shape + stability

	•	marshal ls --json output and assert:
	•	top-level has schema_version="1.0"
	•	each element has all required fields (including nullables)
	•	timestamps are RFC3339Nano parseable when present
	•	derived_status for non-broken rows equals status.Derive output

integration-ish test (light, no binary exec)
	•	create temp ${AGENCY_DATA_DIR} layout:
	•	repos/r1/runs/20260110-a3f2/meta.json valid
	•	repos/r2/runs/20260110-bbbb/meta.json valid
	•	repos/r2/runs/20260110-bad1/meta.json corrupt
	•	include minimal repo.json for r1 only
	•	run the ls handler with:
	•	cwd “not in repo” mode (stub) and --all-repos --all --json
	•	assert:
	•	exit 0
	•	includes all three run_ids
	•	corrupt run has broken=true
	•	r1 run has repo_key/origin_url populated; r2 runs have nulls if repo.json absent

note: do not depend on tmux presence in tests. stub tmux session existence checker to always false.
tmux listing should be invoked at most once per `ls` call in tests (verify via stub call count).

⸻

guardrails
	•	do not add any dependency for table formatting or ansi
	•	do not introduce any gh calls (grep for gh  in code is acceptable as an extra check)
	•	do not write to any state files during ls
	•	do not emit events for ls
	•	do not import tmux capture functionality (only session existence check is allowed)

⸻

manual demo (acceptance)
	1.	inside a repo with runs:

agency ls
agency ls --all
agency ls --json | jq .

	2.	outside any repo:

cd /tmp
agency ls
agency ls --all --json | jq .

	3.	broken meta:

	•	manually corrupt one ${AGENCY_DATA_DIR}/repos/<repo_id>/runs/<run_id>/meta.json
	•	agency ls --all-repos --json still exits 0 and shows broken=true

⸻

done criteria
	•	agency ls matches scope defaults exactly (in-repo vs out-of-repo)
	•	agency ls --json matches schema/version and is stable
	•	broken metas are surfaced without failing ls
	•	no state files are mutated; no gh calls are introduced
	•	go test ./... passes

⸻

claude prompt pack (execution)

commands

git status --porcelain
go test ./...          # confirm baseline

implement
	•	create/modify only the files listed in this spec.
	•	follow existing CLI framework patterns in the repo (do not refactor command setup).

verify

go test ./...
# optional: run manual demos if you have a repo with existing agency data

constraints (repeat)
	•	no gh calls
	•	no writes during ls
	•	no new indexes
	•	no new deps
	•	no tmux pid inspection
