# agency s2 pr-01 spec: run discovery + parsing + “broken run” records

## goal
implement filesystem-based run discovery and robust parsing for `meta.json`, plus best-effort joins to `repo.json` and `repo_index.json`, producing a stable in-memory representation (`store.RunRecord`) that later PRs can render without surprises.

this PR must not add any CLI output/handlers yet; it only builds the store layer and tests.

---

## non-goals
- no command wiring (`agency ls/show` not implemented here)
- no derived status logic
- no tmux interaction
- no transcript capture
- no `gh` calls (no network)
- no new indexes (discovery is scanning the existing directory layout)
- no mutation of `repo_index.json`, `repo.json`, `meta.json` (read-only)

---

## public surface area
none (internal-only go package).

---

## files to create
- `internal/store/types.go`
- `internal/store/scan.go`
- `internal/store/repo_index.go`
- `internal/store/scan_test.go`
- `internal/store/repo_index_test.go`

(optional: `internal/store/testdata/` is allowed, but prefer temp-dir fixtures in tests.)

---

## persistence contract (read-only)
this PR **reads** only:

- `${AGENCY_DATA_DIR}/repos/*/runs/*/meta.json`
- `${AGENCY_DATA_DIR}/repos/<repo_id>/repo.json` (best-effort; may be missing/corrupt)
- `${AGENCY_DATA_DIR}/repo_index.json` (best-effort; may be missing/corrupt)

this PR **does not write** any files.

---

## core types (locked; do not drift)

package: `internal/store`

### `Meta` (parsed `meta.json`)
`Meta` must include the fields required by L0’s `meta.json` contract (minimum set needed for s2):

```go
package store

import "time"

type Meta struct {
	SchemaVersion    string    `json:"schema_version"`
	RunID            string    `json:"run_id"`
	RepoID           string    `json:"repo_id"`
	Title            string    `json:"title"`
	Runner           string    `json:"runner"`
	ParentBranch     string    `json:"parent_branch"`
	Branch           string    `json:"branch"`
	WorktreePath     string    `json:"worktree_path"`
	CreatedAt        time.Time `json:"created_at"`
	TmuxSessionName  string    `json:"tmux_session_name"`

	// optional (nullable in json; use pointers)
	PrNumber    *int       `json:"pr_number,omitempty"`
	PrURL       *string    `json:"pr_url,omitempty"`
	LastPushAt  *time.Time `json:"last_push_at,omitempty"`
	LastVerifyAt *time.Time `json:"last_verify_at,omitempty"`

	Flags struct {
		NeedsAttention bool `json:"needs_attention,omitempty"`
		SetupFailed    bool `json:"setup_failed,omitempty"`
		Abandoned      bool `json:"abandoned,omitempty"`
	} `json:"flags,omitempty"`

	Archive struct {
		ArchivedAt *time.Time `json:"archived_at,omitempty"`
		MergedAt   *time.Time `json:"merged_at,omitempty"`
	} `json:"archive,omitempty"`
}

notes:
	•	json tags must match l0
	•	tolerate missing optional objects (flags, archive) by using zero-values
	•	schema_version must be present for non-broken records; s2 does not validate its value

RepoInfo (parsed repo.json join)

this is best-effort and may be nil in RunRecord.

type RepoInfo struct {
	RepoKey    string  `json:"repo_key"`
	OriginURL  *string `json:"origin_url,omitempty"`
	// additional fields in repo.json are ignored
}

RunRecord

this is the sole output of scanning. broken meta must still produce a record.

type RunRecord struct {
	RepoID  string
	RunID   string
	Broken  bool

	Meta *Meta       // nil if Broken==true
	Repo *RepoInfo   // nil if missing/corrupt

	RunDir   string  // absolute path: ${DATA}/repos/<repo_id>/runs/<run_id>
}


⸻

scanning contract

directory layout assumptions

runs live at:
	•	${AGENCY_DATA_DIR}/repos/<repo_id>/runs/<run_id>/meta.json

discovery is implemented by scanning:
	•	${AGENCY_DATA_DIR}/repos/*/runs/*/meta.json

broken meta handling (locked)

RunRecord identity is canonical from directory names:
	•	RunRecord.RepoID = <repo_id> directory name
	•	RunRecord.RunID = <run_id> directory name
	•	meta.RepoID / meta.RunID are display data only; never override identity

mark broken if any of:
	•	meta.json unreadable
	•	json unmarshal fails
	•	Meta.SchemaVersion == "" or Meta.CreatedAt.IsZero()

if meta.json cannot be read or parsed:
	•	RunRecord.Broken = true
	•	RunRecord.RunID = <run_id> (directory name)
	•	RunRecord.RepoID = <repo_id> (directory name)
	•	RunRecord.Meta = nil
	•	RunRecord.RunDir set correctly
	•	join to repo.json still attempted best-effort (Repo may still populate)

ls must never crash on corrupt meta; this PR enables that by construction.

repo join handling (locked)

for each repo_id, attempt to load:
	•	${DATA}/repos/<repo_id>/repo.json

if missing or corrupt:
	•	do not mark run broken
	•	set Repo=nil and continue
	•	cache repo.json by repo_id (including missing/corrupt => nil) to avoid repeated reads

repo_index join + repo_root selection (display-only)

load ${DATA}/repo_index.json best-effort.
then compute RepoRoot only if:
	•	Repo != nil and Repo.RepoKey non-empty

RepoRoot is computed by PickRepoRoot (below) in the command layer. this value is for printing and default-scope selection only. it must not affect run discovery or run_id resolution.
RepoRoot is not stored in RunRecord; it is computed on demand at render/command time.

⸻

required functions (locked)

scanning

// ScanAllRuns discovers runs across all repos by scanning the filesystem.
// It must be resilient: missing directories => empty result; corrupt meta => Broken record.
func ScanAllRuns(dataDir string) ([]RunRecord, error)

// ScanRunsForRepo discovers runs for a single repo_id.
func ScanRunsForRepo(dataDir string, repoID string) ([]RunRecord, error)

notes:
	•	ScanRunsForRepo should avoid scanning every repo when repoID is known
	•	ScanAllRuns returns records sorted by RepoID asc, then RunID asc (stable order)
	•	ScanRunsForRepo returns records sorted by RunID asc (stable order)

repo index

repo_index.json is best-effort; define minimal types that can parse a map.

type RepoIndex struct {
	// key: repo_key
	Entries map[string]RepoIndexEntry `json:"entries"`
}

type RepoIndexEntry struct {
	SeenPaths []string  `json:"seen_paths"`
	// optional: MostRecentPath string, LastSeenAt time.Time (ignore if absent)
	MostRecentPath *string `json:"most_recent_path,omitempty"`
}

loading:

func LoadRepoIndex(dataDir string) (*RepoIndex, error)

loader behavior (locked):
	•	missing file => (nil, nil)
	•	invalid json => (nil, err)
	•	accept either top-level map[string]RepoIndexEntry or { "entries": map[...] }

repo root selection (locked preference order)

// PickRepoRoot selects a repo root path for DISPLAY ONLY.
//
// preference order:
// 1) if cwdRepoRoot != nil and exists on disk, prefer it
// 2) idx.MostRecentPath if set and exists on disk
// 3) first existing path from idx.SeenPaths
// 4) nil
func PickRepoRoot(repoKey string, cwdRepoRoot *string, idx *RepoIndex) *string

rules:
	•	never hit network
	•	existence check must use os.Stat and require isDir
	•	if idx is nil or entry missing and cwdRepoRoot is nil: return nil

⸻

behaviors (given/when/then)

discovery returns broken record
	•	given: ${DATA}/repos/r1/runs/20260110-a3f2/meta.json is invalid json
	•	when: ScanAllRuns(DATA, nil)
	•	then: result includes RunRecord{RepoID:"r1", RunID:"20260110-a3f2", Broken:true, Meta:nil}

repo.json join is best-effort
	•	given: repo.json missing for repo_id r1
	•	when: scan runs
	•	then: RunRecord.Repo == nil but Broken depends only on meta parse

repo_index + PickRepoRoot order
	•	given:
	•	cwdRepoRoot matches repoKey and exists on disk
	•	most_recent_path exists too
	•	when: PickRepoRoot(repoKey, &cwdRepoRoot, idx)
	•	then: returns cwdRepoRoot
	•	given: cwdRepoRoot nil
	•	most_recent_path exists
	•	then: returns most_recent_path
	•	given: most_recent missing, some seen_paths exist, only second exists
	•	then: returns that existing path
	•	given: none exist
	•	then: returns nil

⸻

tests (must exist)

internal/store/scan_test.go

use t.TempDir() to build a fake ${DATA} tree.

required test cases:
	1.	valid + corrupt meta

	•	create:
	•	${DATA}/repos/r1/runs/20260110-a3f2/meta.json valid (minimal required fields)
	•	${DATA}/repos/r1/runs/20260110-a3ff/meta.json corrupt
	•	${DATA}/repos/r2/runs/20260110-b111/meta.json valid
	•	optionally create repo.json for r1 only
	•	assert:
	•	3 records returned
	•	corrupt one: Broken=true, Meta=nil, RunID from dir, RepoID from dir
	•	valid ones: Broken=false, RunRecord identity from dir names
	•	include one meta with mismatched RunID/RepoID and assert RunRecord identity stays with dir names (meta preserved for debugging)

	2.	missing dirs safe

	•	empty ${DATA}
	•	ScanAllRuns returns empty slice, nil error

	3.	ScanRunsForRepo scopes correctly

	•	with multiple repos, ScanRunsForRepo(DATA, “r1”) returns only r1 runs

	4.	deterministic ordering

	•	create runs in non-sorted order
	•	assert ScanAllRuns returns sorted by RepoID, then RunID
	•	assert ScanRunsForRepo returns sorted by RunID

internal/store/repo_index_test.go

table-driven tests for PickRepoRoot preference order:
	•	cwd wins
	•	most_recent wins
	•	first existing seen_path wins
	•	nil when none exist
	•	nil when idx missing entry

and a test for LoadRepoIndex:
	•	missing file returns (nil, nil)
	•	invalid json returns (nil, err)
	•	accepts both top-level map and { "entries": ... } wrapper

⸻

guardrails
	•	do not add any command code under cmd/agency/*
	•	do not add new deps
	•	do not validate meta schema strictly (be resilient; broken records instead)
	•	do not write any files (no last_seen, no index updates)

⸻

demo

go test ./... -run StoreScan
go test ./... -run PickRepoRoot


⸻

done checklist
	•	scanning works across repos and for single repo
	•	corrupt meta produces Broken records without failing scan
	•	RunRecord identity always matches directory names (meta mismatch does not override)
	•	ScanAllRuns/ScanRunsForRepo return deterministic order (RepoID/RunID sorting)
	•	repo.json and repo_index.json joins are best-effort and never mark runs broken
	•	LoadRepoIndex handles missing file + invalid json + both top-level shapes
	•	PickRepoRoot follows the exact preference order and is fully tested
	•	go test ./... passes
