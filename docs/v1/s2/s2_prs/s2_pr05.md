# agency s2 pr-05 spec: `agency show <id>` (human + `--json` + `--path`) (no capture)

## goal
ship `agency show <id>` so a user can inspect a single run deterministically from anywhere (inside or outside a repo), with:
- exact/unique-prefix id resolution across all repos
- rich human output
- stable `--json` output
- `--path` mode that prints only resolved filesystem paths

this PR must be local-only: no network calls, no transcript capture, no state mutation.

---

## non-goals
- no `--capture` (tmux capture-pane) and no transcript files
- no `gh` calls (no refresh, no network)
- no `agency.json` schema changes
- no changes to how runs are discovered (still filesystem scan)
- no new indexes/caches
- no meta/repo_index mutation (no last_seen writes)
- no runner pid inspection (`tmux_active` == tmux session exists)
- no events emission in this PR (show without capture is read-only)

---

## public surface area

### command
`agency show <id>`

### flags (must exist)
- `--json` : stable machine output envelope
- `--path` : print only resolved filesystem paths (no other text)

### id resolution (locked)
- accepts exact `run_id` or a **unique** prefix of `run_id`
- resolution is global (works regardless of cwd)
- ambiguous prefix => `E_RUN_ID_AMBIGUOUS` (non-zero)
- not found => `E_RUN_NOT_FOUND` (existing code)

### broken-run behavior (locked)
- `ls` can show broken runs, but `show` targeting a broken run must fail:
  - exit non-zero with error code `E_RUN_BROKEN`
  - human output includes:
    - path to the unreadable `meta.json`
    - recovery hint: “delete this run dir or fix meta.json”
  - `--json` output must still be produced (best-effort) and include `broken=true`

> policy: `show` requires parsed meta to compute most fields; broken runs are not actionable.

---

## dependencies (must use)
- discovery: `store.ScanAllRuns(dataDir)` from pr-01 (do not add new discovery code)
- id resolution: the resolver from pr-02 (or the already-agreed resolver shape)
- status derivation: `status.Derive(meta, Snapshot)` from pr-03
- repo root display: `store.PickRepoRoot(...)` (best-effort, display-only)
- tmux session existence check: same helper used by `ls` (no pid inspection)

---

## output contracts

### human output (default)
`agency show <id>` prints:

#### header / core
- run_id
- title
- runner
- created_at (absolute timestamp)
- repo_id
- repo_key (if known)
- origin_url (if known)

#### git/workspace
- parent_branch
- branch
- worktree_path
- worktree_present (yes/no)
- tmux_session_name
- tmux_active (yes/no)

#### pr (if present in meta)
- pr_number
- pr_url
- last_push_at

#### report
- report_path (`<worktree>/.agency/report.md`)
- report_exists (yes/no)
- report_bytes (int)

#### scripts/logs (paths surfaced only; do not parse logs)
- setup log path
- verify log path
- archive log path
- if known in meta/out: last exit code/duration for setup/verify/archive (only if those fields already exist in meta; do not invent new ones here)

#### derived
- derived_status (string)
- archived (bool)

#### warnings (only when relevant)
- if repo root cannot be resolved from repo_index: warn “repo not found on disk”
- if worktree missing: note “worktree archived/missing”

formatting constraints:
- keep it plain text, sections with labels
- no new table libs / deps

### `--path` output (locked)
prints only paths, one per line, in this exact order and label format:

repo_root: 
worktree_root: <worktree_path>
run_dir: <run_dir>
logs_dir: <logs_dir>
events_path: <events_path>
transcript_path: <transcript_path>
report_path: <report_path>

rules:
- if repo_root is unknown: print `repo_root:` with empty value
- transcript_path must be printed even though capture is not implemented yet (it’s the canonical location)
- `--path` must not print any other text, warnings, or status

### `--json` output (stable)
`agency show <id> --json` must output:

```json
{
  "schema_version": "1.0",
  "data": { /* RunDetail */ }
}

RunDetail (types locked)

type RunDetail = {
  meta: object | null            // parsed meta.json object; null if broken
  repo_id: string
  repo_key: string | null
  origin_url: string | null
  archived: boolean
  derived: {
    derived_status: string
    tmux_active: boolean
    worktree_present: boolean
    report: { exists: boolean, bytes: number, path: string }
    logs: { setup_log_path: string, verify_log_path: string, archive_log_path: string }
  }
  paths: {
    repo_root: string | null
    worktree_root: string
    run_dir: string
    events_path: string
    transcript_path: string
  }
  broken: boolean
}

json rules:
	•	if meta is broken: meta=null, broken=true, and the rest is best-effort using run_dir + conventions
	•	logs paths must be present as strings even if files missing
	•	all paths must be absolute (where applicable) and deterministic

⸻

file path conventions (must follow)

given:
	•	run_dir = ${AGENCY_DATA_DIR}/repos/<repo_id>/runs/<run_id>
	•	events_path = <run_dir>/events.jsonl
	•	transcript_path = <run_dir>/transcript.txt
	•	worktree_root = meta.worktree_path (for non-broken)
	•	report_path = <worktree_root>/.agency/report.md
	•	logs_dir = <run_dir>/logs
	•	log paths:
	•	<logs_dir>/setup.log
	•	<logs_dir>/verify.log
	•	<logs_dir>/archive.log

important: if your existing s1 implementation uses different log filenames, do not change it. instead:

	•	surface the actual existing paths from s1 conventions
	•	only fall back to the above names if s1 did not standardize names yet

make the chosen log path convention explicit in code with a single helper.

⸻

read-only guarantee

this PR must not write or mutate any state:
	•	no events.jsonl writes
	•	no transcript writes
	•	no meta.json writes
	•	no repo_index updates

⸻

files to create/modify (exact)

create
	•	internal/render/show.go
	•	func RenderShowHuman(w io.Writer, d RunDetailHuman) error
	•	func RenderShowPaths(w io.Writer, p PathsOnly) error

modify
	•	cmd/agency/show.go
	•	add command + flags
	•	implement global scan, resolve id, load record
	•	compute snapshot booleans
	•	output human/json/path modes
	•	internal/render/json.go
	•	add RunDetail struct + envelope (schema_version)
	•	(reuse existing json helpers from pr-04; do not duplicate)

do not refactor ls or shared json types beyond what is necessary to reuse helpers.

⸻

behaviors (given/when/then)

global resolution
	•	given: runs exist in repo A and repo B
	•	when: run agency show <id-from-repo-b> while cwd is inside repo A
	•	then: show still finds and displays repo B run

ambiguous id
	•	given: 20260110-a3f2 and 20260110-a3ff
	•	when: agency show 20260110-a3f
	•	then: exits non-zero E_RUN_ID_AMBIGUOUS and prints candidates

broken meta targeted
	•	given: ${run_dir}/meta.json is invalid json
	•	when: agency show <run_id>
	•	then: exits non-zero E_RUN_BROKEN
	•	and: prints path to meta.json + hint
	•	and: --json outputs broken=true and meta=null

path mode
	•	when: agency show <id> --path
	•	then: prints only path lines in the locked order, no warnings

⸻

tests (must exist)

unit tests
	1.	id prefix resolution across repos

	•	create synthetic list of RunRecord with differing repo_ids
	•	ensure resolver behavior is correct (0/1/many)

	2.	show json shape

	•	build a RunDetail from a fixture meta and assert:
	•	envelope schema_version == “1.0”
	•	required fields exist
	•	timestamps and nulls behave (if meta includes times)

	3.	broken targeted

	•	simulate a broken RunRecord (Broken=true, Meta=nil)
	•	show handler returns E_RUN_BROKEN and still produces json with broken=true

integration-ish test (light, no binary exec)
	•	create temp ${AGENCY_DATA_DIR} with:
	•	one valid run meta
	•	one corrupt meta
	•	run show handler for each:
	•	valid: exit 0, json includes derived fields
	•	corrupt: exit non-zero E_RUN_BROKEN, json broken=true

test constraints:
	•	do not require tmux installed; stub tmux session check to false
	•	do not require filesystem worktree exists for json shape test; but at least one integration fixture should include a fake worktree dir + report file so report bytes logic is exercised

⸻

guardrails
	•	no network calls (gh, http, etc.)
	•	no writes to any agency state files
	•	do not modify repo_index.json in any way
	•	do not add new deps
	•	do not add --capture

⸻

manual demo (acceptance)

# from anywhere
agency show <run_id>
agency show <run_id_prefix>
agency show <run_id> --json | jq .
agency show <run_id> --path

broken:
	•	corrupt ${AGENCY_DATA_DIR}/repos/<repo_id>/runs/<run_id>/meta.json
	•	agency show <run_id> fails with E_RUN_BROKEN; agency ls --all-repos still lists it.

⸻

done criteria
	•	agency show works from inside/outside repos
	•	exact + unique-prefix id resolution works
	•	--path prints only the locked path lines
	•	--json matches schema/version and is stable
	•	broken run targeted fails with E_RUN_BROKEN but ls remains unaffected
	•	go test ./... passes

⸻

claude prompt pack (execution)

commands

git status --porcelain
go test ./...

implement
	•	implement cmd/agency/show.go + render/json additions exactly as specified
	•	reuse store/ids/status packages; do not re-implement scanning or derivation

verify

go test ./...

constraints (repeat)
	•	no gh calls
	•	no writes during show (without capture)
	•	no new deps
	•	no --capture in this PR
