# agency s2 pr-03 spec: derived status computation (pure) + tests

## goal
implement a **pure**, local-only status derivation function that converts (meta + local snapshot) into:
- `derived_status` (human display string)
- `archived` (bool)
- `report_nonempty` (bool; bytes >= 64)

this PR must be fully unit-tested with an explicit precedence matrix. no filesystem, tmux, or network calls inside the status package.

---

## non-goals
- no CLI wiring (`ls/show` untouched)
- no filesystem reads (no `os.Stat` here)
- no tmux calls / pid inspection
- no `gh` calls
- no writing to meta/logs/events
- no rendering (table output / json output)

---

## public surface area
none (internal-only go package).

---

## files to create
- `internal/status/derive.go`
- `internal/status/derive_test.go`

---

## inputs and outputs (locked)

package: `internal/status`

### inputs
status derivation depends only on:
- meta fields (including flags and terminal outcome markers)
- local snapshot booleans/ints provided by caller

```go
package status

import "github.com/NielsdaWheelz/agency/internal/store"

type Snapshot struct {
	TmuxActive     bool // v1: true iff tmux session exists
	WorktreePresent bool // true iff meta.WorktreePath exists on disk
	ReportBytes    int  // 0 if missing or unreadable
}

type Derived struct {
	DerivedStatus  string
	Archived       bool
	ReportNonempty bool
}

func Derive(meta *store.Meta, in Snapshot) Derived

constraints:
	•	meta may be nil in callers for broken runs; in that case:
	•	DerivedStatus must be "broken"
	•	Archived must be !in.WorktreePresent (still meaningful)
	•	ReportNonempty derived from bytes threshold (still meaningful)
	•	Derive must not panic on nil meta
	•	clamp ReportBytes < 0 to 0

⸻

terminology and constants (locked)

report heuristic
	•	report_nonempty is true iff ReportBytes >= 64
	•	constant must be defined in the status package (not duplicated elsewhere):
	•	const ReportNonemptyThresholdBytes = 64

archived
	•	Archived is true iff WorktreePresent == false
	•	callers will still show an “(archived)” suffix in rendering; this package only returns the boolean
	•	Archived is presence-derived in v1; meta.archive.* does not affect Archived

⸻

precedence rules (locked)

derive DerivedStatus without network calls using the following precedence order.

0) broken run

if meta == nil:
	•	DerivedStatus = "broken"

(then still apply archived suffix later in rendering; do not append suffix here.)

1) terminal outcome always wins

terminal outcome is recorded only from meta (no gh calls):
	•	if meta.Archive.MergedAt != nil: DerivedStatus = "merged"
	•	else if meta.Flags.Abandoned == true: DerivedStatus = "abandoned"
	•	only Archive.MergedAt indicates merged in v1

2) open-run failure flags

if open (not merged/abandoned):
	•	if meta.Flags.SetupFailed == true: DerivedStatus = "failed"
	•	else if meta.Flags.NeedsAttention == true: DerivedStatus = "needs attention"

3) ready-for-review

if open and not failed/needs-attention:
DerivedStatus = "ready for review" iff all are true:
	•	meta.PrNumber != nil
	•	meta.LastPushAt != nil
	•	ReportBytes >= 64
	open := not merged and not abandoned

4) otherwise: activity fallbacks

if none of the above:
	•	if in.TmuxActive == true and meta.PrNumber != nil: DerivedStatus = "active (pr)"
	•	else if in.TmuxActive == true: DerivedStatus = "active"
	•	else if meta.PrNumber != nil: DerivedStatus = "idle (pr)"
	•	else: DerivedStatus = "idle"

notes:
	•	this package must not mention “(archived)” suffix; that’s render-layer responsibility.
	•	“active (report missing)” is explicitly not part of v1; keep strings minimal and stable.
	•	strings are a user-visible contract and must remain stable across v1.x
	•	broken overrides all activity strings (DerivedStatus is always "broken" when meta is nil)

⸻

tests (must exist)

file: internal/status/derive_test.go

test style
	•	table-driven with explicit meta builder helpers
	•	no filesystem, no time.Now in derive (Meta time values can be dummy)

minimum coverage matrix

you must include cases that prove precedence:
	1.	nil meta => broken

	•	meta=nil, snapshot worktree present true/false
	•	expect DerivedStatus “broken”

	2.	merged wins

	•	meta has archive.merged_at set
	•	also set setup_failed / needs_attention / ready_for_review conditions true
	•	expect “merged”
	•	add case with worktree_present=false => DerivedStatus “merged”, Archived true

	3.	abandoned wins

	•	meta.flags.abandoned true
	•	also set setup_failed true
	•	expect “abandoned”

	4.	setup_failed beats needs_attention

	•	open run, setup_failed true, needs_attention true
	•	expect “failed”

	5.	needs_attention beats ready_for_review

	•	open run, needs_attention true, pr_number set, last_push set, report>=64
	•	expect “needs attention”

	6.	ready_for_review predicate

	•	open run, pr_number set, last_push set, report=64
	•	expect “ready for review”
	•	and a negative case for each missing predicate:
	•	missing pr_number => not ready
	•	missing last_push_at => not ready
	•	report=63 => not ready

	7.	activity fallbacks

	•	tmux_active=true, pr_number!=nil => “active (pr)”
	•	tmux_active=true, pr_number==nil => “active”
	•	tmux_active=false, pr_number!=nil => “idle (pr)”
	•	tmux_active=false, pr_number==nil => “idle”

	8.	archived boolean

	•	worktree_present=false => Derived.Archived true (in all cases)
	•	worktree_present=true => false

	9.	report_nonempty boolean

	•	report bytes 0, 63 => false
	•	64, 100 => true
	•	report bytes -1 => false (clamped)

helper requirements (recommended)

create small helper functions in the test file:
	•	mkMeta(fn func(*store.Meta)) *store.Meta
	•	ptrTime(t time.Time) *time.Time
	•	ptrInt(n int) *int

keep helpers local to tests.

⸻

guardrails
	•	do not add new strings beyond the ones specified (treat as user-visible contract)
	•	do not append archived suffix here
	•	no external deps
	•	derive.go may import store only; no other internal packages
	•	no touching store scanning or command layer

⸻

demo

go test ./... -run Derive


⸻

done checklist
	•	internal/status/Derive is pure (no os/tmux/gh imports)
	•	nil meta returns “broken” and does not panic
	•	precedence rules implemented exactly
	•	table tests cover all precedence cases and predicate negatives
	•	go test ./... passes
