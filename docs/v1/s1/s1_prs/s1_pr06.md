# agency slice 01 — pr-06: run dir + meta.json writer (v1 mvp)

## goal

persist durable run state immediately after worktree creation by creating the run directory (`runs/<run_id>/`) and writing an initial `meta.json` (atomic), so later steps (setup/tmux) can fail while leaving a debuggable record.

---

## scope

### in-scope

- implement the previously-stubbed “write meta” step in the s1 run pipeline (introduced in pr-04) so that **after worktree creation** (pr-05) we:

  1) create the run directory with exclusive semantics:

  - `${AGENCY_DATA_DIR}/repos/<repo_id>/runs/<run_id>/` (must fail if it already exists)
  - `${AGENCY_DATA_DIR}/repos/<repo_id>/runs/<run_id>/logs/`

  2) write `${...}/runs/<run_id>/meta.json` **atomically** with required fields (below)

- ensure the initial meta includes the **resolved `runner_cmd`** string (from pr-03) and the computed branch/worktree path (from pr-05), plus timestamps.
  - `runner` is the runner name (e.g. "claude" or "codex"), not inferred from runner_cmd
  - `runner_cmd` is the verbatim command string (may include args/wrappers)
  - `title` is stored exactly as resolved; do not slugify

- update pipeline wiring so that:
  - on success: meta is written before any later steps (setup/tmux in later prs)
  - on failure (run dir exists / write fails): return a structured `AgencyError` with correct code and details, and **do not delete** anything.

### out-of-scope

- no setup script execution (pr-07)
- no tmux session creation (pr-08)
- no cli changes (no new flags/commands)
- no events.jsonl (deferred to slice 2)
- no locks / concurrency beyond “fail if run dir exists” (slice 2 owns lock semantics)
- no retries on collisions

---

## public surface area

### persistent formats (written in this pr)

- `${AGENCY_DATA_DIR}/repos/<repo_id>/runs/<run_id>/meta.json`
- `${AGENCY_DATA_DIR}/repos/<repo_id>/runs/<run_id>/logs/` (dir)

### new error codes

add to the public error code list (l0) if missing:

- `E_RUN_DIR_EXISTS` — `${...}/runs/<run_id>/` already exists (run id collision / stale state)
- `E_RUN_DIR_CREATE_FAILED` — failed to create the run directory (non-exist error)
- `E_META_WRITE_FAILED` — failed to write meta.json atomically

(existing error codes used here)
- `E_SCRIPT_FAILED` not used
- `E_WORKTREE_CREATE_FAILED` not used
- json write failures must surface as `AgencyError{code: E_META_WRITE_FAILED}`.

---

## required behavior

### meta.json schema (written by pr-06)

write `meta.json` with:

required fields:
- `schema_version`: string, exactly `"1.0"`
- `run_id`: string
- `repo_id`: string
- `title`: string
- `runner`: string (`"claude"` or `"codex"`; this is the runner *name*, not the command)
- `runner_cmd`: string (verbatim shell command snippet resolved from `agency.json`; do not parse)
- `parent_branch`: string
- `branch`: string (full branch name `agency/<slug>-<shortid>`)
- `worktree_path`: string (absolute path)
- `created_at`: rfc3339 utc timestamp (e.g. `time.Now().UTC().Format(time.RFC3339)`)

must be absent in this pr:
- `tmux_session_name` (only set when tmux is successfully created in pr-08)
- any `pr_*` fields
- any `last_push_at`, `last_verify_at`

optional fields allowed (only if already part of the codebase / schema):
- `flags.setup_failed` (do not set here)
- `flags.tmux_failed` (do not set here)
- `last_seen_at` (ok if already used elsewhere; not required)

### atomic write requirement

all json writes in this pr must use the atomic writer helper from pr-01:
- write to temp file in same directory
- best-effort fsync (if helper already does this, reuse it)
- rename to final path
 - temp filename pattern: `.meta.json.tmp.<pid>.<rand>` (or equivalent)
 - on success: only meta.json remains
 - on failure: temp file may remain; meta.json must be unchanged or absent

### run dir creation requirement

- create `runs/<run_id>/` such that it fails if it already exists:
  - use `os.Mkdir(runDir, 0o700)`
  - if exists: return `AgencyError` with `code=E_RUN_DIR_EXISTS`, include `run_dir` in details
  - if mkdir fails for any other reason: return `AgencyError` with `code=E_RUN_DIR_CREATE_FAILED`
- create `logs/` inside run dir (`os.MkdirAll`) after run dir exists with mode `0o700`
- do not “clean up” on partial failure; leave whatever was created

---

## integration points / implementation constraints

### where to implement

- add a small internal module for run persistence (name it consistently with existing code; suggested: `internal/store` or `internal/state`)
- it must expose one focused function used by the pipeline step, conceptually:

  - `EnsureRunDir(repoID, runID) (runDir string, err error)`
  - `WriteInitialMeta(repoID, runID, meta) error`

you do **not** need to freeze exact names if the repo already has a pattern; follow existing style, but keep it small and testable.
this module must not import git or tmux packages; only core + fs helpers.

### pipeline wiring

- locate the pipeline skeleton from pr-04 (the step currently stubbed as “WriteMeta” / similar).
- replace the stub with the real implementation:
  - called after worktree creation succeeds
  - on any error, propagate immediately, preserving error code
  - if worktree_path does not exist or is not a directory: return `E_INTERNAL` with details (step + path)

---

## acceptance (given/when/then)

### 1) run dir created once

**given**
- computed repo_id and run_id
- worktree exists (from pr-05)

**when**
- write-meta step executes

**then**
- `${AGENCY_DATA_DIR}/repos/<repo_id>/runs/<run_id>/` exists
- `${...}/logs/` exists
- `meta.json` exists and parses as json
- required fields are present and correct
- `created_at` is utc rfc3339 (ends with Z; parse with time.RFC3339)
- `tmux_session_name` is absent

### 2) run dir collision fails cleanly

**given**
- `${...}/runs/<run_id>/` already exists

**when**
- write-meta step executes

**then**
- step fails with `E_RUN_DIR_EXISTS`
- error details include the run dir path
- existing `meta.json` is not modified
- do not create or modify logs/ on collision

### 3) meta write failure surfaces correct error

**given**
- run dir exists but atomic write fails (simulate via temp dir permissions in test)

**when**
- write-meta step executes

**then**
- step fails with `E_META_WRITE_FAILED` (or your chosen io code)
- error includes cause + target path
- no partial meta file remains (atomic helper guarantees this)

---

## tests

### unit tests (required)

- `TestWriteInitialMeta_RequiredFields`:
  - writes meta to a temp `${AGENCY_DATA_DIR}`
  - reads it back and asserts required fields
  - asserts `schema_version == "1.0"`
  - asserts `created_at` parses as rfc3339 and ends with `Z` (utc)

- `TestEnsureRunDir_Collision`:
  - create run dir once
  - call again and assert `E_RUN_DIR_EXISTS`

- `TestWriteInitialMeta_IsAtomic`:
  - write meta once
  - write meta again with a different title
  - ensure file equals second version and JSON is valid

### integration tests (recommended; may be behind build tag)

- create temp git repo with one commit and a minimal `agency.json`
- run the internal “worktree create” function from pr-05, then run pr-06 meta step
- assert run dir + meta exists

(no tmux, no scripts)

---

## guardrails

- do not add any cli flags or commands
- do not implement setup/tmux/resume/ls
- do not modify git state beyond what pr-05 already does
- do not introduce new persistent formats beyond:
  - run dir + logs dir + meta.json
- do not add third-party deps
- do not silently retry on collisions

---

## definition of done

- `go test ./...` passes
- unit tests above exist and pass
- running the s1 flow up to pr-06 stage leaves:
  - worktree directory present
  - run dir present
  - meta.json present with correct required fields

---

## implementation prompt (optional)

run these from repo root:

1) tests first / current state
```bash
go test ./...
```

2) implement pr-06 exactly:
- find the pipeline stub step from pr-04 ("WriteMeta")
- implement run dir creation (runs/<run_id>/ + logs/) with collision failure
- write initial meta.json atomically using the helper from pr-01
- ensure meta includes runner_cmd (verbatim) and excludes tmux/pr fields

3) run tests
```bash
go test ./...
```

constraints:
- no new commands, no tmux, no setup execution
- keep changes scoped to persistence + pipeline wiring + tests
- if you discover naming mismatches (different package names than assumed), adapt
  to repo conventions; do not invent a new architecture
