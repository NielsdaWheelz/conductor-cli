# agency slice 01 — pr-02 spec: repo detection + safety gates + repo.json update

## goal

implement the “safe to start” checks used by `agency run` and persist/update per-repo state (`repo.json`) without mutating git state.

---

## scope

### in-scope

- resolve repo root from cwd
- compute `repo_id` using the existing slice-00 rules (reuse code; do not reimplement)
- ensure `${AGENCY_DATA_DIR}/repos/<repo_id>/repo.json` exists
- update `repo.json` fields:
  - `last_seen_at` (utc rfc3339)
  - `origin_url` (string; empty if missing)
- implement repo safety gates used by slice 01:
  - parent working tree cleanliness check at repo root checkout
  - empty repo check (must have at least one commit)
  - local parent branch existence check

### out-of-scope

- no git fetch/checkout/rebase/reset, no `git worktree` operations
- no tmux behavior
- no script execution
- no cli wiring for `agency run` yet (this pr is internal plumbing)
- do not change the repo-id algorithm or origin parsing rules from slice 00
- no new persistent formats beyond updating/creating `repo.json` as specified
- if repo root cannot be resolved, do not write any files

---

## public surface area added/changed

### internal api (new or finalized in this pr)

add a single internal entrypoint that s1 can call:

```go
// CheckRepoSafe resolves repo root + repo_id, updates repo.json,
// and applies safety gates required for starting a run.
func CheckRepoSafe(ctx context.Context, opts CheckRepoSafeOpts) (*RepoContext, error)

type CheckRepoSafeOpts struct {
  // ParentBranch is the local branch name to branch from, e.g. "main".
  ParentBranch string
}

type RepoContext struct {
  RepoRoot   string // absolute path to git toplevel
  RepoID     string // computed via s0 rules
  OriginURL  string // empty if not present
}

you may add additional small helpers/types inside the same package, but do not add more exported APIs than the above without updating this spec.

⸻

persistence

files written (global)
	•	${AGENCY_DATA_DIR}/repos/<repo_id>/repo.json
	•	must be created if missing
	•	must be updated if present
	•	writes must be atomic (temp file in same dir + rename)
	•	json schema/versioning must follow slice 00 rules (additive only)
	•	import and reuse the slice 00 repo.json struct/type and writer
	•	this pr must not define a new repo.json struct
	•	repo.json file mode must be 0644
	•	directories created in this flow must be 0755

repo.json fields in this pr

this pr must ensure at minimum these fields exist and are updated correctly:
	•	schema_version (match slice 00, e.g. "1.0" if that’s what s0 uses)
	•	repo_id
	•	repo_root (absolute path; if s0 already stores a different key name, keep s0’s name)
	•	last_seen_at (utc rfc3339)
	•	origin_url (string, empty if missing)

compat constraint: if slice 00 already defines additional required fields or different field names, follow slice 00 as source of truth. do not fork schemas.

⸻

behaviors (given / when / then)

1) resolves repo root

given
	•	cwd is inside a git repo

when
	•	CheckRepoSafe(ctx, { ParentBranch: "main" })

then
	•	repo root is resolved via git rev-parse --show-toplevel
	•	returned RepoContext.RepoRoot is absolute path to toplevel
	•	repo.json exists under ${AGENCY_DATA_DIR}/repos/<repo_id>/repo.json and has updated last_seen_at

errors:
	•	if not inside a repo: return E_NO_REPO
	•	on E_NO_REPO: do not create/update any files

⸻

2) parent working tree dirty gate

given
	•	repo root checkout has uncommitted changes:
	•	git status --porcelain is non-empty

when
	•	CheckRepoSafe(...)

then
	•	return E_PARENT_DIRTY
	•	must not create worktrees/branches (none exist in this pr anyway)
	•	repo.json may be updated (allowed) but no other state is written

⸻

3) empty repo gate

given
	•	repo exists but has no commits (fresh git init)
	•	git rev-parse --verify HEAD fails

when
	•	CheckRepoSafe(...)

then
	•	return E_EMPTY_REPO

⸻

4) local parent branch missing gate

given
	•	repo has commits, but refs/heads/<parent> does not exist locally:
	•	checked via git show-ref --verify refs/heads/<parent>

when
	•	CheckRepoSafe(ctx, { ParentBranch: "<parent>" })

then
	•	return E_PARENT_BRANCH_NOT_FOUND
	•	include actionable hint in error message: “checkout/fetch parent locally (no fetch in v1 s1)”

⸻

5) origin url persistence

given
	•	repo has a remote named origin

when
	•	CheckRepoSafe(...)

then
	•	OriginURL is read (best-effort) and stored in repo.json
	•	use git remote get-url origin
	•	if origin missing:
	•	OriginURL is empty (not omitted)
	•	repo.json still created/updated

⸻

error codes

this pr must return these codes exactly in the specified scenarios:
	•	E_NO_REPO — cannot resolve repo root from cwd
	•	E_PARENT_DIRTY — git status --porcelain non-empty in repo root
	•	E_EMPTY_REPO — git rev-parse --verify HEAD fails
	•	E_PARENT_BRANCH_NOT_FOUND — git show-ref --verify refs/heads/<parent> fails

implementation notes:
	•	wrap underlying stderr as cause/details on AgencyError, but error code must be stable.
	•	do not introduce new error codes in this pr.
	•	exit mapping:
		•	git rev-parse --verify HEAD: any non-zero => E_EMPTY_REPO (include stderr)
		•	git status --porcelain: non-empty stdout => E_PARENT_DIRTY; non-zero => E_PARENT_DIRTY (include stderr)
		•	git show-ref --verify: any non-zero => E_PARENT_BRANCH_NOT_FOUND (include stderr)

⸻

commands executed (must be exact)

all git commands must be run with cwd = repo_root unless specified:
	1.	resolve repo root:

	•	git rev-parse --show-toplevel

	2.	origin url (best-effort; do not fail if missing):

	•	git remote get-url origin

	3.	empty repo gate:

	•	git rev-parse --verify HEAD

	4.	dirty gate:

	•	git status --porcelain

	5.	parent branch existence gate:

	•	git show-ref --verify refs/heads/<parent_branch>

constraints:
	•	no git fetch
	•	no git checkout
	•	no modifications to refs or working tree
	•	after resolving repo_root, do not run git commands from the original cwd

ordering (must be deterministic):
	1.	resolve repo root
	2.	compute repo_id
	3.	read origin url (best-effort)
	4.	write/update repo.json (last_seen_at, origin_url)
	5.	run gates (empty repo, dirty, parent branch)

⸻

tests

automated tests (required)

integration tests (required)
use temp directories; do not rely on user’s environment.

test cases:
	1.	clean repo passes

	•	create temp repo
	•	commit one file on default branch
	•	determine current branch via git branch --show-current
	•	run CheckRepoSafe with ParentBranch set to that branch
	•	assert: no error; repo.json exists; last_seen_at set

	2.	dirty repo fails with E_PARENT_DIRTY

	•	modify a tracked file without committing
	•	assert error code is E_PARENT_DIRTY

	3.	empty repo fails with E_EMPTY_REPO

	•	git init only, no commits
	•	assert error code is E_EMPTY_REPO

	4.	missing parent branch fails with E_PARENT_BRANCH_NOT_FOUND

	•	create repo with commit but no local branch of that name
	•	assert error code is E_PARENT_BRANCH_NOT_FOUND

also assert for at least one test:
	•	when origin exists, origin_url is written
	•	when origin missing, origin_url is empty and no error
	•	repo.json file mode is 0644 (best-effort; check permission bits on unix)

notes:
	•	tests must not call tmux
	•	tests must not call gh

manual verification (optional but helpful)

# in a real repo with clean tree + local main:
go test ./...

# dirty check:
echo x >> README.md
# run the internal test harness or a small dev main if you have it


⸻

guardrails (follow, unless doing so forces you to do something stupid)
	•	do not modify git state (no fetch/checkout)
	•	do not add any tmux or worktree code
	•	do not add new persistent files besides repo.json updates
	•	do not change slice-00 repo_id/origin parsing rules (reuse only)
	•	keep changes scoped to the minimal packages needed (internal/git, internal/repo, internal/core)
	•	do not touch cmd/agency
	•	no new third-party dependencies

⸻

definition of done
	•	all required integration tests pass: go test ./...
	•	repo.json is created/updated atomically and contains updated last_seen_at
	•	CheckRepoSafe returns correct error codes for all failure modes above
	•	no git state is mutated beyond reading commands
